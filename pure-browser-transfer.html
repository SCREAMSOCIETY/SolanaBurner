<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SolBurn - Pure Manual cNFT Transfer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <style>
    body {
      font-family: 'Arial', sans-serif;
      background-color: #f5f5f5;
      padding: 20px;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: #fff;
      border-radius: 10px;
      padding: 30px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    .header h1 {
      color: #512da8;
      font-weight: bold;
    }
    .logo {
      width: 100px;
      height: 100px;
    }
    .status {
      margin: 20px 0;
      padding: 15px;
      border-radius: 5px;
    }
    .status.success {
      background-color: #d4edda;
      color: #155724;
    }
    .status.error {
      background-color: #f8d7da;
      color: #721c24;
    }
    .status.warning {
      background-color: #fff3cd;
      color: #856404;
    }
    .status.info {
      background-color: #d1ecf1;
      color: #0c5460;
    }
    .btn-primary {
      background-color: #512da8;
      border-color: #4527a0;
    }
    .btn-primary:hover {
      background-color: #4527a0;
      border-color: #311b92;
    }
    .btn-secondary {
      background-color: #7e57c2;
      border-color: #673ab7;
    }
    .btn-secondary:hover {
      background-color: #673ab7;
      border-color: #5e35b1;
    }
    .card {
      margin-bottom: 15px;
      border: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .card-header {
      background-color: #eee6ff;
      border-bottom: none;
      font-weight: bold;
    }
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(81, 45, 168, 0.3);
      border-radius: 50%;
      border-top-color: #512da8;
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    .nft-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    .nft-item {
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      transition: transform 0.2s;
      position: relative;
    }
    .nft-item:hover {
      transform: translateY(-5px);
    }
    .nft-item.selected {
      box-shadow: 0 0 0 3px #512da8, 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    .nft-image {
      width: 100%;
      aspect-ratio: 1;
      object-fit: cover;
    }
    .nft-name {
      font-size: 0.85rem;
      padding: 8px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      background-color: #fff;
    }
    .log-container {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 20px;
      padding: 10px;
      border-radius: 5px;
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      font-family: monospace;
      font-size: 0.85rem;
    }
    .log-entry {
      margin-bottom: 5px;
    }
    .log-time {
      color: #6c757d;
      margin-right: 5px;
    }
    .selected-count {
      margin-top: 15px;
      font-weight: bold;
      color: #512da8;
    }
    .selection-badge {
      position: absolute;
      top: 5px;
      right: 5px;
      background-color: #512da8;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>SolBurn - Pure Manual cNFT Transfer</h1>
      <p class="lead">Trash your unwanted compressed NFTs - No Library Dependencies</p>
    </div>

    <div id="walletSection">
      <div class="card mb-4">
        <div class="card-header">Connect Your Wallet</div>
        <div class="card-body">
          <div id="wallet-connect-buttons" class="d-flex gap-2">
            <button id="connect-phantom" class="btn btn-primary">
              <img src="/phantom.svg" alt="Phantom" width="20" height="20" class="me-2">
              Connect Phantom
            </button>
            <button id="connect-solflare" class="btn btn-secondary">
              <img src="/solflare.svg" alt="Solflare" width="20" height="20" class="me-2">
              Connect Solflare
            </button>
          </div>
          <div id="wallet-info" class="mt-3 hidden">
            <p>Connected: <span id="wallet-address"></span></p>
            <button id="disconnect-wallet" class="btn btn-sm btn-outline-danger">Disconnect</button>
          </div>
        </div>
      </div>
    </div>

    <div id="assetSection" class="hidden">
      <div class="card mb-4">
        <div class="card-header">Your Compressed NFTs</div>
        <div class="card-body">
          <div id="loading-assets" class="text-center">
            <span class="loading me-2"></span> Loading your assets...
          </div>
          <div id="no-assets" class="alert alert-info hidden">
            No compressed NFTs found in your wallet.
          </div>
          <div id="asset-error" class="alert alert-danger hidden"></div>
          <div id="nft-grid" class="nft-grid hidden"></div>
          <div id="selected-count" class="selected-count hidden">
            Selected: <span id="count-number">0</span>
          </div>
        </div>
      </div>

      <div id="actionSection" class="hidden">
        <div class="card mb-4">
          <div class="card-header">Actions</div>
          <div class="card-body">
            <p class="text-muted mb-3">
              Selected cNFTs will be transferred to the project wallet for proper disposal.
              This action cannot be undone.
            </p>
            <button id="trash-selected" class="btn btn-danger" disabled>
              Trash Selected cNFTs
            </button>
          </div>
        </div>
      </div>
    </div>

    <div id="logSection" class="hidden">
      <div class="card">
        <div class="card-header">Operation Log</div>
        <div class="card-body p-0">
          <div id="log-container" class="log-container"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Load Solana Web3.js from CDN -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  
  <!-- Load Buffer from CDN for browser compatibility -->
  <script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.min.js"></script>
  
  <!-- Load BS58 from CDN -->
  <script src="https://bundle.run/bs58@5.0.0"></script>

  <script>
    // Main app script
    document.addEventListener('DOMContentLoaded', function() {
      // Constants and configuration
      const BUBBLEGUM_PROGRAM_ID = new solanaWeb3.PublicKey('BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY');
      const SPL_NOOP_PROGRAM_ID = new solanaWeb3.PublicKey('noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV');
      const SPL_ACCOUNT_COMPRESSION_PROGRAM_ID = new solanaWeb3.PublicKey('cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK');
      const PROJECT_WALLET = new solanaWeb3.PublicKey('EYjsLzE9VDy3WBd2beeCHA1eVYJxPKVf6NoKKDwq7ujK');

      // Element references
      const walletSection = document.getElementById('walletSection');
      const assetSection = document.getElementById('assetSection');
      const actionSection = document.getElementById('actionSection');
      const logSection = document.getElementById('logSection');
      const connectPhantomBtn = document.getElementById('connect-phantom');
      const connectSolflareBtn = document.getElementById('connect-solflare');
      const walletInfo = document.getElementById('wallet-info');
      const walletAddress = document.getElementById('wallet-address');
      const disconnectWalletBtn = document.getElementById('disconnect-wallet');
      const loadingAssets = document.getElementById('loading-assets');
      const noAssets = document.getElementById('no-assets');
      const assetError = document.getElementById('asset-error');
      const nftGrid = document.getElementById('nft-grid');
      const selectedCount = document.getElementById('selected-count');
      const countNumber = document.getElementById('count-number');
      const trashSelectedBtn = document.getElementById('trash-selected');
      const logContainer = document.getElementById('log-container');

      // App state
      let wallet = null;
      let publicKey = null;
      let assets = [];
      let selectedAssets = [];

      // Initialize the Solana connection
      const connection = new solanaWeb3.Connection("https://api.mainnet-beta.solana.com", "confirmed");

      // Logging functions
      function log(message, type = 'info') {
        const now = new Date();
        const time = now.toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry log-${type}`;
        logEntry.innerHTML = `<span class="log-time">[${time}]</span> ${message}`;
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
        
        // Show log section
        logSection.classList.remove('hidden');
      }

      // Helper function to shorten address
      function shortenAddress(address, chars = 4) {
        return `${address.slice(0, chars)}...${address.slice(-chars)}`;
      }

      // Connect to wallet
      async function connectWallet(walletName) {
        try {
          log(`Connecting to ${walletName}...`);
          
          if (walletName === 'phantom') {
            if (!window.phantom?.solana) {
              throw new Error('Phantom wallet not found. Please install the Phantom extension.');
            }
            wallet = window.phantom.solana;
          } else if (walletName === 'solflare') {
            if (!window.solflare?.solana) {
              throw new Error('Solflare wallet not found. Please install the Solflare extension.');
            }
            wallet = window.solflare.solana;
          }
          
          // Connect to the wallet
          const resp = await wallet.connect();
          publicKey = resp.publicKey.toString();
          
          // Update UI
          walletInfo.classList.remove('hidden');
          walletAddress.textContent = shortenAddress(publicKey);
          document.getElementById('wallet-connect-buttons').classList.add('hidden');
          
          // Show asset section
          assetSection.classList.remove('hidden');
          
          log(`Connected to wallet: ${shortenAddress(publicKey)}`);
          
          // Load assets
          loadAssets();
        } catch (error) {
          log(`Error connecting to wallet: ${error.message}`, 'error');
          console.error('Wallet connection error:', error);
        }
      }

      // Load assets from wallet
      async function loadAssets() {
        try {
          if (!publicKey) {
            throw new Error('Wallet not connected');
          }
          
          // Reset state
          assets = [];
          selectedAssets = [];
          updateSelectedCount();
          
          // Show loading
          loadingAssets.classList.remove('hidden');
          noAssets.classList.add('hidden');
          assetError.classList.add('hidden');
          nftGrid.classList.add('hidden');
          nftGrid.innerHTML = '';
          
          log(`Loading assets for wallet: ${shortenAddress(publicKey)}...`);
          
          // Fetch assets using the server API
          const response = await fetch(`/api/helius/wallet-assets/${publicKey}`);
          const data = await response.json();
          
          if (!data.success) {
            throw new Error(data.error || 'Failed to fetch assets');
          }
          
          // Filter for compressed NFTs
          assets = data.data.filter(asset => asset.compression && asset.compression.compressed);
          
          // Hide loading
          loadingAssets.classList.add('hidden');
          
          if (assets.length === 0) {
            noAssets.classList.remove('hidden');
            log('No compressed NFTs found in wallet.');
            return;
          }
          
          log(`Found ${assets.length} compressed NFTs.`);
          
          // Render assets
          renderAssets();
          
          // Show action section
          actionSection.classList.remove('hidden');
        } catch (error) {
          loadingAssets.classList.add('hidden');
          assetError.textContent = error.message;
          assetError.classList.remove('hidden');
          log(`Error loading assets: ${error.message}`, 'error');
          console.error('Asset loading error:', error);
        }
      }

      // Render assets in grid
      function renderAssets() {
        nftGrid.innerHTML = '';
        
        assets.forEach((asset, index) => {
          const nftItem = document.createElement('div');
          nftItem.className = 'nft-item';
          nftItem.dataset.index = index;
          
          // Create image element
          const img = document.createElement('img');
          img.className = 'nft-image';
          img.src = asset.content?.files?.[0]?.uri || asset.content?.image || '/default-nft-image.svg';
          img.alt = asset.content?.metadata?.name || `NFT #${index}`;
          img.onerror = () => { img.src = '/default-nft-image.svg'; };
          
          // Create name element
          const name = document.createElement('div');
          name.className = 'nft-name';
          name.textContent = asset.content?.metadata?.name || `NFT #${index}`;
          
          // Selection badge (hidden by default)
          const badge = document.createElement('div');
          badge.className = 'selection-badge hidden';
          badge.textContent = 'âœ“';
          
          // Append elements
          nftItem.appendChild(img);
          nftItem.appendChild(name);
          nftItem.appendChild(badge);
          
          // Add click handler
          nftItem.addEventListener('click', () => {
            toggleAssetSelection(nftItem, asset);
          });
          
          nftGrid.appendChild(nftItem);
        });
        
        nftGrid.classList.remove('hidden');
      }

      // Toggle asset selection
      function toggleAssetSelection(nftItem, asset) {
        const index = parseInt(nftItem.dataset.index);
        const isSelected = nftItem.classList.toggle('selected');
        const badge = nftItem.querySelector('.selection-badge');
        
        if (isSelected) {
          selectedAssets.push(assets[index]);
          badge.classList.remove('hidden');
        } else {
          selectedAssets = selectedAssets.filter(a => a.id !== assets[index].id);
          badge.classList.add('hidden');
        }
        
        updateSelectedCount();
      }

      // Update selected count
      function updateSelectedCount() {
        countNumber.textContent = selectedAssets.length;
        
        if (selectedAssets.length > 0) {
          selectedCount.classList.remove('hidden');
          trashSelectedBtn.disabled = false;
        } else {
          selectedCount.classList.add('hidden');
          trashSelectedBtn.disabled = true;
        }
      }

      // Get asset proof from API
      async function getAssetProof(assetId) {
        try {
          log(`Fetching proof for asset: ${shortenAddress(assetId, 6)}...`);
          
          const response = await fetch(`/api/helius/asset-proof/${assetId}`);
          const data = await response.json();
          
          if (!data.success) {
            throw new Error(data.error || 'Failed to fetch asset proof');
          }
          
          return data.data;
        } catch (error) {
          log(`Error fetching asset proof: ${error.message}`, 'error');
          throw error;
        }
      }

      /**
       * Creates a transfer instruction manually for Bubblegum cNFTs
       * 
       * @param {object} accounts - The accounts needed for the transfer
       * @param {object} args - The arguments needed for the transfer
       * @returns {solanaWeb3.TransactionInstruction} - The transfer instruction
       */
      function createManualTransferInstruction(accounts, args) {
        log("Creating manual transfer instruction...");
        
        // Accounts required for the instruction
        const keys = [
          // Tree Authority - ReadOnly
          {
            pubkey: accounts.treeAuthority,
            isSigner: false,
            isWritable: false,
          },
          // Leaf Owner - ReadOnly, Signer (must sign because they're transferring)
          {
            pubkey: accounts.leafOwner,
            isSigner: true,
            isWritable: false,
          },
          // Leaf Delegate (same as owner in direct transfers) - ReadOnly, Signer
          {
            pubkey: accounts.leafDelegate,
            isSigner: true,
            isWritable: false,
          },
          // New Leaf Owner (recipient) - ReadOnly
          {
            pubkey: accounts.newLeafOwner,
            isSigner: false,
            isWritable: false,
          },
          // Merkle Tree - Writable
          {
            pubkey: accounts.merkleTree,
            isSigner: false,
            isWritable: true,
          },
          // Log Wrapper - ReadOnly
          {
            pubkey: accounts.logWrapper,
            isSigner: false,
            isWritable: false,
          },
          // Compression Program - ReadOnly
          {
            pubkey: accounts.compressionProgram,
            isSigner: false,
            isWritable: false,
          },
        ];

        // Create the instruction data buffer manually
        // 8 is a standard offset for Anchor instructions
        const instructionData = new Uint8Array(1 + 8 + 32 + 32 + 8 + 8 + (args.proof.length * 32));
        
        // Transfer instruction discriminator (5 = transfer in Bubblegum program)
        instructionData[0] = 5;
        
        // Write root hash (32 bytes)
        instructionData.set(args.root, 1 + 8);
        
        // Write data hash (32 bytes)
        instructionData.set(args.dataHash, 1 + 8 + 32);
        
        // Write creator hash (32 bytes)
        instructionData.set(args.creatorHash, 1 + 8 + 32 + 32);
        
        // Write nonce and index (8 bytes each)
        // In JavaScript we can't directly write big integers to a byte array
        // So we use DataView for this specific part
        const view = new DataView(instructionData.buffer);
        view.setBigUint64(1 + 8 + 32 + 32, BigInt(args.index), true); // true = littleEndian
        view.setBigUint64(1 + 8 + 32 + 32 + 8, BigInt(args.index), true);
        
        // Write proofs
        let proofOffset = 1 + 8 + 32 + 32 + 8 + 8;
        for (let i = 0; i < args.proof.length; i++) {
          instructionData.set(args.proof[i], proofOffset + (i * 32));
        }

        log("Created manual instruction data");
        
        // Create and return the instruction
        return new solanaWeb3.TransactionInstruction({
          keys,
          programId: BUBBLEGUM_PROGRAM_ID,
          data: instructionData
        });
      }

      // Trash selected assets
      async function trashSelectedAssets() {
        if (selectedAssets.length === 0) {
          log('No assets selected.', 'warning');
          return;
        }
        
        if (!confirm(`Are you sure you want to trash ${selectedAssets.length} selected cNFTs? This action cannot be undone.`)) {
          return;
        }
        
        // Disable button during processing
        trashSelectedBtn.disabled = true;
        
        log(`Starting trash operation for ${selectedAssets.length} cNFTs...`);
        
        for (let i = 0; i < selectedAssets.length; i++) {
          const asset = selectedAssets[i];
          try {
            log(`Processing cNFT ${i+1}/${selectedAssets.length}: ${asset.content?.metadata?.name || shortenAddress(asset.id, 8)}`);
            
            // Get proof data
            const proofData = await getAssetProof(asset.id);
            log(`Got proof data for ${shortenAddress(asset.id, 8)}`);
            
            // Create transfer transaction using manual approach
            await transferAsset(asset, proofData);
            
            // Update UI to show success
            const nftItem = document.querySelector(`.nft-item[data-index="${assets.findIndex(a => a.id === asset.id)}"]`);
            if (nftItem) {
              nftItem.style.opacity = "0.5";
              nftItem.style.pointerEvents = "none";
            }
          } catch (error) {
            log(`Error processing asset ${asset.id}: ${error.message}`, 'error');
            console.error('Asset processing error:', error);
          }
        }
        
        log('Trash operation completed.');
        
        // Re-enable button
        trashSelectedBtn.disabled = false;
        
        // Refresh assets
        setTimeout(() => {
          loadAssets();
        }, 2000);
      }

      // Transfer asset using pure manual approach
      async function transferAsset(asset, proofData) {
        try {
          log(`Creating transfer transaction for ${shortenAddress(asset.id, 8)}...`);
          
          // Convert public key string to PublicKey object
          const senderPublicKey = new solanaWeb3.PublicKey(publicKey);
          
          // Get the merkle tree public key
          const merkleTree = new solanaWeb3.PublicKey(proofData.tree_id);
          
          // Derive the tree authority PDA
          const [treeAuthority] = solanaWeb3.PublicKey.findProgramAddressSync(
            [merkleTree.toBuffer()],
            BUBBLEGUM_PROGRAM_ID
          );
          
          // Extract data from proof
          const dataHash = proofData.leaf?.data_hash || "11111111111111111111111111111111";
          const creatorHash = proofData.leaf?.creator_hash || "11111111111111111111111111111111";
          
          // Prepare accounts for the transfer instruction
          const accounts = {
            merkleTree,
            treeAuthority,
            leafOwner: senderPublicKey,
            leafDelegate: senderPublicKey,
            newLeafOwner: PROJECT_WALLET,
            logWrapper: SPL_NOOP_PROGRAM_ID,
            compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
          };
          
          // Convert base64 strings to Uint8Arrays
          const root = new Uint8Array(Buffer.from(proofData.root, 'base64'));
          const dataHashBytes = new Uint8Array(Buffer.from(dataHash, 'base64'));
          const creatorHashBytes = new Uint8Array(Buffer.from(creatorHash, 'base64'));
          const proof = proofData.proof.map(p => new Uint8Array(Buffer.from(p, 'base64')));
          
          // Prepare arguments for the transfer instruction
          const args = {
            root,
            dataHash: dataHashBytes,
            creatorHash: creatorHashBytes,
            index: proofData.node_index,
            proof,
          };
          
          // Create manual transfer instruction
          const transferIx = createManualTransferInstruction(accounts, args);
          
          // Create transaction
          const transaction = new solanaWeb3.Transaction();
          transaction.add(transferIx);
          transaction.feePayer = senderPublicKey;
          
          // Get latest blockhash
          const { blockhash } = await connection.getLatestBlockhash('confirmed');
          transaction.recentBlockhash = blockhash;
          
          log(`Requesting wallet signature...`);
          
          // Ask the wallet to sign the transaction
          const signed = await wallet.signTransaction(transaction);
          
          log(`Transaction signed, submitting to network...`);
          
          // Send the transaction to the network
          const signature = await connection.sendRawTransaction(signed.serialize());
          
          log(`Transaction submitted with ID: ${signature}`);
          log(`Waiting for confirmation...`);
          
          // Confirm the transaction
          const confirmation = await connection.confirmTransaction(signature);
          
          if (confirmation.value.err) {
            log(`Transaction confirmed but failed: ${JSON.stringify(confirmation.value.err)}`, 'error');
            throw new Error(`Transaction error: ${JSON.stringify(confirmation.value.err)}`);
          }
          
          log(`Transaction successful! Asset ${shortenAddress(asset.id, 8)} trashed.`, 'success');
          
          return signature;
        } catch (error) {
          log(`Transfer error: ${error.message}`, 'error');
          throw error;
        }
      }

      // Event listeners
      connectPhantomBtn.addEventListener('click', () => connectWallet('phantom'));
      connectSolflareBtn.addEventListener('click', () => connectWallet('solflare'));
      
      disconnectWalletBtn.addEventListener('click', async () => {
        try {
          if (wallet) {
            await wallet.disconnect();
          }
          
          // Reset state
          wallet = null;
          publicKey = null;
          assets = [];
          selectedAssets = [];
          
          // Update UI
          walletInfo.classList.add('hidden');
          document.getElementById('wallet-connect-buttons').classList.remove('hidden');
          assetSection.classList.add('hidden');
          actionSection.classList.add('hidden');
          
          log('Wallet disconnected.');
        } catch (error) {
          log(`Error disconnecting wallet: ${error.message}`, 'error');
        }
      });
      
      trashSelectedBtn.addEventListener('click', trashSelectedAssets);
      
      // Check for connected wallet on page load
      async function checkConnectedWallet() {
        try {
          if (window.phantom?.solana?.isPhantom) {
            wallet = window.phantom.solana;
            
            // Check if already connected
            const resp = await wallet.connect({ onlyIfTrusted: true });
            if (resp && resp.publicKey) {
              publicKey = resp.publicKey.toString();
              
              // Update UI
              walletInfo.classList.remove('hidden');
              walletAddress.textContent = shortenAddress(publicKey);
              document.getElementById('wallet-connect-buttons').classList.add('hidden');
              
              // Show asset section
              assetSection.classList.remove('hidden');
              
              log(`Already connected to wallet: ${shortenAddress(publicKey)}`);
              
              // Load assets
              loadAssets();
            }
          }
          // Similar check for Solflare could be added here
        } catch (error) {
          // Silent error - user not connected yet
          console.log('No trusted connection:', error);
        }
      }
      
      // Initialize
      checkConnectedWallet();
    });
  </script>
</body>
</html>