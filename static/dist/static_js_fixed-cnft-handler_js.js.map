{"version":3,"file":"static_js_fixed-cnft-handler_js.js","mappings":";;;;;;;;;;;;;;;;;;AAA2F;AAI/C;AACpB;;AAExB;AACA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAS;AACxB;AACA,YAAY,0EAAoB;AAChC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM,MAAM,4CAAI;AACrD;AACA,mBAAmB,sDAAS;AAC5B;AACA,gBAAgB,0EAAoB;AACpC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6FAAyB;AACpD;AACA;AACA;AACA;AACA,kCAAkC,sDAAS;AAC3C;AACA,4BAA4B,sDAAS;AACrC,qBAAqB,MAAM;AAC3B,wBAAwB,sDAAS;AACjC;AACA,wCAAwC,sDAAS;AACjD;AACA,gCAAgC,sDAAS;AACzC;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,8BAA8B,sDAAS;AACvC;AACA;AACA;AACA;AACA,kCAAkC,sDAAS;AAC3C;AACA;AACA;AACA;AACA,qCAAqC,sDAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAW;AAClC;AACA;AACA;AACA,YAAY,iEAAoB,uBAAuB,gBAAgB;AACvE;AACA;AACA;AACA;AACA,YAAY,iEAAoB,uBAAuB,sBAAsB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://workspace/./static/js/fixed-cnft-handler.js"],"sourcesContent":["import { Connection, PublicKey, Transaction, ComputeBudgetProgram } from \"@solana/web3.js\";\nimport { \n    createTransferInstruction, \n    PROGRAM_ID as BUBBLEGUM_PROGRAM_ID\n} from \"@metaplex-foundation/mpl-bubblegum\";\nimport bs58 from \"bs58\";\n\n// The \"screamsociety.sol\" address to use as default destination\nconst PROJECT_WALLET_ADDRESS = \"EJNt9MPzVay5p9iDtSQMs6PGTUFYpX3rNA55y4wqi5P8\";\n\n/**\n * Get tree authority PDA safely with comprehensive error handling\n * @param {PublicKey} merkleTree - The merkle tree public key\n * @returns {PublicKey} - The derived tree authority\n */\nfunction getTreeAuthorityPDA(merkleTree) {\n    if (!merkleTree) {\n        throw new Error('Merkle tree is null or undefined');\n    }\n    \n    try {\n        // Try normal PublicKey.findProgramAddressSync\n        return PublicKey.findProgramAddressSync(\n            [merkleTree.toBuffer()],\n            BUBBLEGUM_PROGRAM_ID\n        )[0];\n    } catch (error) {\n        console.warn('Error in standard tree authority derivation:', error.message);\n        \n        // Fallback: manually create buffer from base58 string\n        try {\n            const treeAddressStr = merkleTree.toString();\n            console.log('Using fallback with base58 decode for tree:', treeAddressStr);\n            const merkleTreeBuffer = Buffer.from(bs58.decode(treeAddressStr));\n            \n            return PublicKey.findProgramAddressSync(\n                [merkleTreeBuffer],\n                BUBBLEGUM_PROGRAM_ID\n            )[0];\n        } catch (fallbackError) {\n            console.error('Tree authority derivation fallback also failed:', fallbackError);\n            throw new Error('Failed to derive tree authority: ' + fallbackError.message);\n        }\n    }\n}\n\n/**\n * Transfer a cNFT to a project-managed wallet (or any destination)\n * @param {Object} params - Transfer parameters\n * @param {Connection} params.connection - Solana connection\n * @param {Object} params.wallet - User's wallet \n * @param {string} params.assetId - cNFT asset ID\n * @param {Object} params.assetData - The asset data with compression info\n * @param {Array<string>} params.proof - Merkle proof for the asset\n * @param {string} [params.destinationAddress] - Optional destination address (uses project wallet if not specified)\n * @returns {Promise<Object>} - Transfer result\n */\nexport async function safeTransferCNFT(params) {\n    const { \n        connection, \n        wallet, \n        assetId, \n        assetData, \n        proof,\n        destinationAddress = null \n    } = params;\n    \n    console.log(`Initiating safe transfer of cNFT: ${assetId}`);\n    \n    try {\n        if (!wallet || !wallet.publicKey) {\n            throw new Error('Wallet not connected');\n        }\n        \n        if (!assetData) {\n            throw new Error('Missing asset data');\n        }\n        \n        if (!proof || !Array.isArray(proof) || proof.length === 0) {\n            throw new Error('Missing or invalid proof data');\n        }\n        \n        // Get tree address safely with fallbacks\n        const treeAddress = assetData.compression?.tree || \n                          assetData.tree_id || \n                          assetData.merkle_tree;\n                          \n        if (!treeAddress) {\n            console.error('Missing tree address in asset data:', assetData);\n            throw new Error('Missing tree address in asset data');\n        }\n        \n        console.log('Using tree address:', treeAddress);\n        const merkleTree = new PublicKey(treeAddress);\n        \n        // Get tree authority using our safe function\n        const treeAuthority = getTreeAuthorityPDA(merkleTree);\n        \n        // Target address (default to project wallet if none provided)\n        const targetAddress = destinationAddress || PROJECT_WALLET_ADDRESS;\n        \n        // Log key information for debugging\n        console.log(\"Tree authority:\", treeAuthority.toString());\n        console.log(\"Merkle tree:\", merkleTree.toString());\n        console.log(\"Leaf owner (wallet):\", wallet.publicKey.toString());\n        console.log(\"Target address:\", targetAddress);\n        \n        // Create transfer instruction with all necessary accounts\n        const transferIx = createTransferInstruction(\n            {\n                treeAuthority,\n                leafOwner: wallet.publicKey,\n                leafDelegate: wallet.publicKey, // Owner is also delegate\n                newLeafOwner: new PublicKey(targetAddress),\n                merkleTree,\n                logWrapper: PublicKey.findProgramAddressSync(\n                    [Buffer.from('log', 'utf8')],\n                    new PublicKey('noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV')\n                )[0],\n                compressionProgram: new PublicKey('cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK'),\n                anchorRemainingAccounts: proof.map((node) => ({\n                    pubkey: new PublicKey(node),\n                    isSigner: false,\n                    isWritable: false\n                }))\n            },\n            {\n                root: [...new PublicKey(\n                    assetData.compression?.root || \n                    assetData.root || \n                    \"11111111111111111111111111111111\"\n                ).toBytes()],\n                dataHash: [...new PublicKey(\n                    assetData.compression?.data_hash || \n                    (assetData.leaf && assetData.leaf.data_hash) || \n                    \"11111111111111111111111111111111\"\n                ).toBytes()],\n                creatorHash: [...new PublicKey(\n                    assetData.compression?.creator_hash || \n                    (assetData.leaf && assetData.leaf.creator_hash) || \n                    \"11111111111111111111111111111111\"\n                ).toBytes()],\n                nonce: assetData.compression?.leaf_id || \n                       assetData.node_index || \n                       assetData.leaf_id || \n                       0,\n                index: assetData.compression?.leaf_id || \n                       assetData.node_index || \n                       assetData.leaf_id || \n                       0,\n            }\n        );\n        \n        // Create transaction and add instructions\n        const tx = new Transaction();\n        \n        // Add compute budget instructions for complex compression operations\n        tx.add(\n            ComputeBudgetProgram.setComputeUnitLimit({ units: 1000000 })\n        );\n        \n        // Add priority fee to help the transaction get processed faster\n        tx.add(\n            ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 10000 })\n        );\n        \n        // Add the transfer instruction\n        tx.add(transferIx);\n        \n        // Set fee payer and get recent blockhash\n        tx.feePayer = wallet.publicKey;\n        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();\n        tx.recentBlockhash = blockhash;\n        \n        try {\n            console.log(\"Signing transfer transaction...\");\n            \n            // Sign the transaction\n            if (!wallet.signTransaction) {\n                throw new Error(\"Wallet doesn't support signTransaction\");\n            }\n            \n            const signed = await wallet.signTransaction(tx);\n            console.log(\"Transaction signed successfully\");\n            \n            // Send the signed transaction\n            console.log(\"Sending signed transaction...\");\n            const signature = await connection.sendRawTransaction(\n                signed.serialize()\n            );\n            \n            console.log(\"Transaction sent. Signature:\", signature);\n            \n            // Wait for confirmation\n            try {\n                const confirmation = await connection.confirmTransaction({\n                    signature,\n                    blockhash,\n                    lastValidBlockHeight\n                }, \"confirmed\");\n                \n                console.log(\"cNFT transfer transaction confirmed:\", confirmation);\n                \n                return {\n                    success: true,\n                    signature,\n                    message: \"Compressed NFT successfully transferred!\",\n                    explorerUrl: `https://solscan.io/tx/${signature}`\n                };\n            } catch (confirmError) {\n                // Confirmation might time out but transaction could still succeed\n                console.warn(\"Confirmation error but transaction may have succeeded:\", confirmError);\n                \n                return {\n                    success: true,\n                    signature,\n                    assumed: true,\n                    message: \"Transaction submitted but confirmation timed out. The transfer is likely to succeed.\",\n                    explorerUrl: `https://solscan.io/tx/${signature}`\n                };\n            }\n        } catch (error) {\n            console.error(\"Error signing or sending transaction:\", error);\n            \n            // Check if user cancelled\n            if (error.message && (\n                error.message.includes(\"User rejected\") || \n                error.message.includes(\"cancelled\") || \n                error.message.includes(\"declined\")\n            )) {\n                return {\n                    success: false,\n                    error: \"Transaction was cancelled by the user\",\n                    cancelled: true\n                };\n            }\n            \n            throw new Error(`Transfer transaction failed: ${error.message}`);\n        }\n    } catch (error) {\n        console.error(\"Error in safeTransferCNFT:\", error);\n        \n        return {\n            success: false,\n            error: error.message || \"Unknown error in cNFT transfer\",\n            cancelled: false\n        };\n    }\n}"],"names":[],"sourceRoot":""}