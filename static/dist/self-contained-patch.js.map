{"version":3,"file":"self-contained-patch.js","mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,QAAQ;AACb,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,qEAAqE,QAAQ;AAC7E;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC,E","sources":["webpack://workspace/./static/js/self-contained-patch.js"],"sourcesContent":["/**\n * Self-contained Patch for CNFTHandler\n * This script patches the CNFTHandler class to use our self-contained implementation\n * that doesn't rely on external TransactionInstruction\n */\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  console.log('[Self-Contained-Patch] Initializing...');\n  \n  // Wait for all scripts to load before applying patch\n  window.addEventListener('load', () => {\n    console.log('[Self-Contained-Patch] Window loaded, applying patch...');\n    \n    // The CNFTHandler is loaded differently based on webpack build\n    // It might be available at window.CNFTHandler or window.cnftHandler.CNFTHandler\n    setTimeout(() => {\n      applyPatch();\n    }, 500); // Wait for scripts to initialize\n  });\n  \n  // Direct patch function\n  function applyPatch() {\n    // Determine where CNFTHandler is located\n    let CNFTHandlerClass = null;\n    let prototype = null;\n    \n    if (window.CNFTHandler) {\n      console.log('[Self-Contained-Patch] Found CNFTHandler on window');\n      CNFTHandlerClass = window.CNFTHandler;\n      prototype = window.CNFTHandler.prototype;\n    } else if (window.cnftHandler && window.cnftHandler.CNFTHandler) {\n      console.log('[Self-Contained-Patch] Found CNFTHandler in cnftHandler module');\n      CNFTHandlerClass = window.cnftHandler.CNFTHandler;\n      prototype = window.cnftHandler.CNFTHandler.prototype;\n    } else {\n      console.error('[Self-Contained-Patch] Unable to find CNFTHandler class');\n      return;\n    }\n    \n    // Check if our self-contained transfer is available\n    if (!window.selfContainedTransfer) {\n      console.error('[Self-Contained-Patch] self-contained-transfer not found, cannot apply patch');\n      return;\n    }\n    \n    console.log('[Self-Contained-Patch] Found required components, applying patch');\n    \n    try {\n      // Save original method\n      const originalTransferCNFTWithProof = prototype.transferCNFTWithProof;\n      \n      // Override with our self-contained implementation\n      prototype.transferCNFTWithProof = async function(assetId, providedProofData, destinationAddress = null) {\n        console.log('[Self-Contained-Patch] Using self-contained implementation');\n        \n        // Basic validation\n        if (!assetId) {\n          return { success: false, error: \"Asset ID is required\" };\n        }\n        \n        if (!providedProofData) {\n          return { success: false, error: \"Proof data is required\" };\n        }\n        \n        try {\n          // Get asset data\n          let assetData;\n          try {\n            const assetResponse = await fetch(`/api/helius/asset/${assetId}`);\n            const assetResult = await assetResponse.json();\n            \n            if (assetResult.success && assetResult.data) {\n              assetData = assetResult.data;\n              console.log('[Self-Contained-Patch] Asset data fetched successfully');\n            } else {\n              throw new Error(\"Failed to fetch asset data\");\n            }\n          } catch (assetError) {\n            console.error('[Self-Contained-Patch] Error fetching asset data:', assetError);\n            throw new Error(\"Failed to get asset data\");\n          }\n          \n          // Default to project wallet if no destination\n          const finalDestination = destinationAddress || \"EYjsLzE9VDy3WBd2beeCHA1eVYJxPKVf6NoKKDwq7ujK\";\n          console.log('[Self-Contained-Patch] Destination wallet:', finalDestination);\n          \n          // Show notification to user\n          if (window.BurnAnimations?.showNotification) {\n            window.BurnAnimations.showNotification(\n              \"Processing cNFT Transfer\",\n              \"Creating transaction with self-contained implementation...\"\n            );\n          }\n          \n          // Use our self-contained implementation\n          console.log('[Self-Contained-Patch] Calling self-contained implementation');\n          const result = await window.selfContainedTransfer.transferCNFT({\n            connection: this.connection,\n            wallet: this.wallet,\n            assetId,\n            destinationAddress: finalDestination,\n            proofData: providedProofData,\n            assetData\n          });\n          \n          // Process result\n          if (result.success) {\n            console.log('[Self-Contained-Patch] Transfer successful!');\n            \n            // Add to hidden assets\n            if (window.hiddenAssets) {\n              window.hiddenAssets.addHiddenAsset(assetId);\n            }\n            \n            // Show achievement notification\n            if (window.BurnAnimations?.showAchievement) {\n              const assetName = assetData?.content?.metadata?.name || \"cNFT\";\n              window.BurnAnimations.showAchievement(\n                \"cNFT Trashed\",\n                `You've successfully trashed ${assetName} to the project collection.`\n              );\n            }\n            \n            // Track stats\n            if (window.checkAchievements) {\n              window.checkAchievements('cnft_trash', 1);\n            }\n            \n            // Return success\n            return {\n              ...result,\n              assetId,\n              assetData\n            };\n          } else {\n            console.error('[Self-Contained-Patch] Transfer failed:', result.error);\n            \n            // Show error notification\n            if (window.BurnAnimations?.showNotification) {\n              window.BurnAnimations.showNotification(\n                \"cNFT Trash Failed\",\n                `Error: ${result.error}`\n              );\n            }\n            \n            return result;\n          }\n        } catch (error) {\n          console.error('[Self-Contained-Patch] Transfer error:', error);\n          \n          // Show error notification\n          if (window.BurnAnimations?.showNotification) {\n            window.BurnAnimations.showNotification(\n              \"cNFT Trash Failed\",\n              `Error: ${error.message}`\n            );\n          }\n          \n          // Fallback to original method\n          try {\n            console.log('[Self-Contained-Patch] Trying original implementation as fallback');\n            return await originalTransferCNFTWithProof.call(this, assetId, providedProofData, destinationAddress);\n          } catch (fallbackError) {\n            console.error('[Self-Contained-Patch] Fallback also failed:', fallbackError);\n            return {\n              success: false,\n              error: error.message,\n              fallbackError: fallbackError.message\n            };\n          }\n        }\n      };\n      \n      console.log('[Self-Contained-Patch] Successfully patched CNFTHandler.transferCNFTWithProof');\n      \n      // Also patch directly onto window for direct access\n      if (window.cnftHandler) {\n        window.cnftHandler.selfContainedTransferCNFT = async function(assetId, proofData, destination) {\n          if (!window.selfContainedTransfer) {\n            return { success: false, error: \"Self-contained transfer not available\" };\n          }\n          \n          try {\n            // Get connection and wallet from window\n            const connection = window._solanaConnection;\n            const wallet = window._solanaWallet;\n            \n            if (!connection || !wallet) {\n              return { success: false, error: \"Connection or wallet not available\" };\n            }\n            \n            // Fetch asset data\n            let assetData;\n            try {\n              const assetResponse = await fetch(`/api/helius/asset/${assetId}`);\n              const assetResult = await assetResponse.json();\n              \n              if (assetResult.success && assetResult.data) {\n                assetData = assetResult.data;\n              } else {\n                throw new Error(\"Failed to fetch asset data\");\n              }\n            } catch (assetError) {\n              console.error(\"Error fetching asset data:\", assetError);\n              throw new Error(\"Failed to get asset data\");\n            }\n            \n            // Use final destination\n            const finalDestination = destination || \"EYjsLzE9VDy3WBd2beeCHA1eVYJxPKVf6NoKKDwq7ujK\";\n            \n            // Use our self-contained implementation directly\n            return await window.selfContainedTransfer.transferCNFT({\n              connection,\n              wallet,\n              assetId,\n              destinationAddress: finalDestination,\n              proofData,\n              assetData\n            });\n          } catch (error) {\n            console.error(\"Global selfContainedTransferCNFT error:\", error);\n            return {\n              success: false,\n              error: error.message\n            };\n          }\n        };\n        \n        console.log('[Self-Contained-Patch] Added direct access method to window.cnftHandler');\n      }\n    } catch (error) {\n      console.error('[Self-Contained-Patch] Error applying patch:', error);\n    }\n  }\n});"],"names":[],"sourceRoot":""}