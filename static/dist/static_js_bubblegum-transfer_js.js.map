{"version":3,"file":"static_js_bubblegum-transfer_js.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+E;AACtB;;AAEzD;AACA;AACA,WAAW,WAAW;AACtB,aAAa,WAAW;AACxB;AACA;AACA,4BAA4B,sDAAS;AACrC;AACA,YAAY,sDAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,uBAAuB,sDAAS;AAChC,UAAU,sCAAsC,sDAAS;AACzD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA,YAAY,wEAAwE;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA,gCAAgC,wDAAW;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC,4HAA+C;AACpF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,sDAAS;AACxC,iCAAiC,sDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,+BAA+B,6FAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAS;AACzC,yBAAyB,MAAM;AAC/B,4BAA4B,sDAAS;AACrC;AACA,4CAA4C,sDAAS;AACrD;AACA;AACA,wCAAwC,sDAAS;AACjD;AACA;AACA,yBAAyB;AACzB;AACA,wCAAwC,sDAAS;AACjD;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA,kCAAkC,sDAAS;AAC3C,kCAAkC,MAAM;AACxC,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,+DAA+D,YAAY;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oEAAoE,uCAAuC;AAC3G;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA,iEAAe,EAAE,uBAAuB","sources":["webpack://workspace/./static/js/bubblegum-transfer.js"],"sourcesContent":["/**\n * Bubblegum Transfer Implementation\n * \n * This module provides functionality for transferring compressed NFTs using the\n * Bubblegum protocol. It handles the creation of transfer instructions and \n * transaction sending.\n */\n\nimport { createTransferInstruction } from '@metaplex-foundation/mpl-bubblegum';\nimport { Transaction, PublicKey } from '@solana/web3.js';\n\n/**\n * Get tree authority PDA\n * @param {PublicKey} merkleTree - The merkle tree public key\n * @returns {PublicKey} - The derived tree authority\n */\nfunction getTreeAuthorityPDA(merkleTree) {\n    const [treeAuthority] = PublicKey.findProgramAddressSync(\n        [merkleTree.toBuffer()],\n        new PublicKey(\"BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY\")\n    );\n    return treeAuthority;\n}\n\n/**\n * Safely converts a PublicKey to a Buffer\n * @param {PublicKey|string} publicKeyOrString - The PublicKey or string to convert\n * @returns {Buffer} - A buffer containing the public key bytes\n */\nfunction safePublicKeyToBuffer(publicKeyOrString) {\n    try {\n        if (typeof publicKeyOrString === 'string') {\n            return new PublicKey(publicKeyOrString).toBuffer();\n        } else if (publicKeyOrString instanceof PublicKey) {\n            return publicKeyOrString.toBuffer();\n        }\n    } catch (e) {\n        console.error(\"Error converting public key to buffer:\", e);\n    }\n    \n    // Return an empty buffer as fallback\n    return Buffer.alloc(32);\n}\n\n/**\n * Transfer a compressed NFT to a specified destination\n * @param {object} params - The transfer parameters\n * @param {Connection} params.connection - Solana connection object\n * @param {WalletAdapter} params.wallet - Wallet adapter with signTransaction method\n * @param {string} params.assetId - Asset ID (mint address) of the cNFT\n * @param {string} params.destinationAddress - Destination wallet address\n * @param {object} params.proofData - The asset proof data\n * @param {object} params.assetData - Additional asset data (optional)\n * @returns {Promise<object>} - The result of the transfer operation\n */\nasync function transferCompressedNFT(params) {\n    const { connection, wallet, assetId, destinationAddress, proofData, assetData } = params;\n    \n    try {\n        console.log(\"Starting Bubblegum transfer with params:\", {\n            assetId,\n            destinationAddress,\n            walletPublicKey: wallet.publicKey.toString(),\n            proofDataAvailable: !!proofData\n        });\n        \n        if (!proofData) {\n            return {\n                success: false,\n                error: \"No proof data provided for cNFT transfer\"\n            };\n        }\n        \n        // Validate required proof data\n        if (!proofData.proof || !proofData.root || !proofData.tree) {\n            console.error(\"Invalid proof data:\", proofData);\n            return {\n                success: false,\n                error: \"Invalid proof data structure\"\n            };\n        }\n        \n        // Get the latest blockhash\n        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();\n        \n        // Create a new transaction\n        const transaction = new Transaction({\n            feePayer: wallet.publicKey,\n            blockhash,\n            lastValidBlockHeight,\n        });\n        \n        // Add compute budget instruction to ensure consistent transaction fees with batch transfers\n        const ComputeBudgetProgram = require('@solana/web3.js').ComputeBudgetProgram;\n        transaction.add(\n            ComputeBudgetProgram.setComputeUnitLimit({ \n                units: 1000000 // Same as batch operations to keep fees consistent\n            })\n        );\n        \n        // Convert tree ID to PublicKey\n        const merkleTree = new PublicKey(proofData.tree);\n        const newLeafOwner = new PublicKey(destinationAddress);\n        \n        console.log(\"Creating transfer instruction with params:\", {\n            merkleTree: merkleTree.toString(),\n            treeAuthority: getTreeAuthorityPDA(merkleTree).toString(),\n            leafOwner: wallet.publicKey.toString(),\n            newLeafOwner: newLeafOwner.toString(),\n            proofLength: proofData.proof.length\n        });\n        \n        // Create the transfer instruction\n        try {\n            const transferIx = createTransferInstruction(\n                {\n                    merkleTree,\n                    treeAuthority: getTreeAuthorityPDA(merkleTree),\n                    leafOwner: wallet.publicKey,\n                    leafDelegate: wallet.publicKey,\n                    newLeafOwner,\n                    logWrapper: PublicKey.findProgramAddressSync(\n                        [Buffer.from(\"log_wrapper\", \"utf8\")],\n                        new PublicKey(\"noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV\")\n                    )[0],\n                    compressionProgram: new PublicKey(\"cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK\"),\n                    anchorRemainingAccounts: [\n                        {\n                            pubkey: new PublicKey(proofData.root),\n                            isSigner: false,\n                            isWritable: false,\n                        },\n                        ...proofData.proof.map((node) => ({\n                            pubkey: new PublicKey(node),\n                            isSigner: false,\n                            isWritable: false,\n                        })),\n                    ],\n                },\n                {\n                    root: [...new PublicKey(proofData.root).toBytes()],\n                    dataHash: [...Buffer.from(proofData.data_hash || \"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\")],\n                    creatorHash: [...Buffer.from(proofData.creator_hash || \"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\")],\n                    nonce: proofData.leaf_id || 0,\n                    index: proofData.leaf_id || 0,\n                }\n            );\n            \n            console.log(\"Transfer instruction created successfully\");\n            transaction.add(transferIx);\n        } catch (err) {\n            console.error(\"Error creating transfer instruction:\", err);\n            return {\n                success: false,\n                error: `Error creating transfer instruction: ${err.message}`\n            };\n        }\n        \n        // Sign and send the transaction\n        try {\n            console.log(\"Signing transaction...\");\n            const signedTx = await wallet.signTransaction(transaction);\n            \n            console.log(\"Sending transaction...\");\n            const signature = await connection.sendRawTransaction(\n                signedTx.serialize(),\n                { skipPreflight: true }\n            );\n            \n            console.log(\"Transaction sent, signature:\", signature);\n            \n            // Confirm the transaction\n            const confirmation = await connection.confirmTransaction({\n                signature,\n                blockhash,\n                lastValidBlockHeight,\n            });\n            \n            if (confirmation.value.err) {\n                console.error(\"Transaction confirmed but has errors:\", confirmation.value.err);\n                return {\n                    success: false,\n                    error: `Transaction confirmed but has errors: ${JSON.stringify(confirmation.value.err)}`,\n                    signature,\n                    explorerUrl: `https://solscan.io/tx/${signature}`\n                };\n            }\n            \n            console.log(\"Transaction confirmed successfully\");\n            return {\n                success: true,\n                signature,\n                message: \"Successfully transferred cNFT\",\n                explorerUrl: `https://solscan.io/tx/${signature}`\n            };\n        } catch (err) {\n            // Check if this is a user rejection\n            if (err.message && (\n                err.message.includes(\"User rejected\") || \n                err.message.includes(\"cancelled\") || \n                err.message.includes(\"declined\")\n            )) {\n                console.log(\"User rejected transaction\");\n                return {\n                    success: false,\n                    error: \"Transaction was cancelled by the user\",\n                    cancelled: true\n                };\n            }\n            \n            console.error(\"Error in transaction signing/sending:\", err);\n            return {\n                success: false,\n                error: `Transaction error: ${err.message}`,\n                cancelled: false\n            };\n        }\n    } catch (error) {\n        console.error(\"Unexpected error in transferCompressedNFT:\", error);\n        return {\n            success: false,\n            error: error.message || \"Unknown error in transferCompressedNFT\",\n            cancelled: false\n        };\n    }\n}\n\n// Make sure bubblegumTransfer is accessible globally for direct access\nif (typeof window !== 'undefined') {\n    window.bubblegumTransfer = { transferCompressedNFT };\n}\n\n// Export the transfer function for module imports\nexport default { transferCompressedNFT };"],"names":[],"sourceRoot":""}