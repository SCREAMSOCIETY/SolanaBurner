{"version":3,"file":"static_js_bubblegum-transfer_js.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAK4C;AACa;;AAEzD;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,kCAAkC,sDAAS;AAC3C,qCAAqC,sDAAS;AAC9C;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,KAAK;;AAEL;AACA;AACA,QAAQ,MAAM;AACd;AACA;AACA;AACA,QAAQ,MAAM;AACd;AACA;AACA;AACA,QAAQ,MAAM;AACd;;AAEA;AACA,4BAA4B,sDAAS;AACrC;AACA,MAAM,0EAAoB;AAC1B;AACA;AACA,gCAAgC,6FAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAS;AACjC,gCAAgC,sDAAS;AACzC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,0EAAoB;AAC1B;;AAEA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA,4BAA4B,wDAAW;AACvC;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://workspace/./static/js/bubblegum-transfer.js"],"sourcesContent":["/**\n * Bubblegum Transfer Implementation for Compressed NFTs\n * \n * This implementation follows the standard Metaplex Bubblegum protocol for transferring\n * compressed NFTs (cNFTs) on Solana. It properly handles the Merkle proofs and uses\n * the Bubblegum program to create the transfer instruction.\n * \n * NEW FEATURE:\n * Includes support for batch transfers of multiple cNFTs in a single transaction\n * which significantly reduces wallet approval friction and blockchain fees.\n */\n\nimport {\n  PROGRAM_ID as BUBBLEGUM_PROGRAM_ID,\n  createTransferInstruction,\n} from '@metaplex-foundation/mpl-bubblegum';\nimport { PublicKey, Transaction } from '@solana/web3.js';\n\n/**\n * Transfer a compressed NFT to a new owner using the Bubblegum protocol\n * \n * @param {Object} params Transfer parameters\n * @param {Connection} params.connection - Solana connection\n * @param {Object} params.wallet - User's wallet with signTransaction method\n * @param {string} params.assetId - The asset ID (mint) of the cNFT\n * @param {string} params.destinationAddress - The address to transfer the cNFT to\n * @param {Object} params.proofData - The Merkle proof data for the cNFT\n * @param {Object} params.assetData - Asset data with compression information\n * @returns {Promise<Object>} Transfer result with transaction signature\n */\nexport async function transferCompressedNFT(params) {\n  const {\n    connection,\n    wallet,\n    assetId,\n    destinationAddress,\n    proofData,\n    assetData,\n  } = params;\n\n  try {\n    console.log('[bubblegum-transfer] Starting cNFT transfer using Bubblegum protocol');\n    console.log('[bubblegum-transfer] Asset ID:', assetId);\n    console.log('[bubblegum-transfer] Destination:', destinationAddress);\n\n    if (!wallet || !wallet.publicKey || !wallet.signTransaction) {\n      throw new Error('Wallet with signTransaction capability required');\n    }\n\n    if (!proofData || !proofData.proof || !proofData.root) {\n      throw new Error('Valid proof data required for Bubblegum transfer');\n    }\n\n    if (!assetData || !assetData.compression || !assetData.compression.tree) {\n      throw new Error('Asset compression data required for Bubblegum transfer');\n    }\n\n    // Extract proof data\n    const {\n      root,\n      proof,\n      leaf_id,\n      leaf,\n      data_hash,\n      creator_hash,\n    } = proofData;\n\n    // Get necessary addresses and data\n    const ownerAddress = wallet.publicKey;\n    const merkleTreeAddress = new PublicKey(assetData.compression.tree);\n    const destinationPublicKey = new PublicKey(destinationAddress);\n    const leafOwner = ownerAddress;\n    const leafDelegate = ownerAddress; // Assuming owner is also delegate\n    const nonce = assetData.compression.leaf_id || leaf_id;\n    const index = assetData.compression.leaf_id || leaf_id;\n\n    console.log('[bubblegum-transfer] Creating Bubblegum transfer instruction');\n    console.log('[bubblegum-transfer] Merkle tree:', merkleTreeAddress.toString());\n    console.log('[bubblegum-transfer] Owner:', ownerAddress.toString());\n    console.log('[bubblegum-transfer] Destination:', destinationPublicKey.toString());\n\n    // Convert proof to right format if needed\n    const bubblegumProof = proof.map(node => {\n      if (typeof node === 'string') {\n        return Buffer.from(node.replace('0x', ''), 'hex');\n      }\n      return node;\n    });\n\n    // Set up root and hashes in the right format\n    const rootArray = typeof root === 'string' \n      ? Buffer.from(root.replace('0x', ''), 'hex') \n      : root;\n      \n    const dataHashArray = typeof data_hash === 'string'\n      ? Buffer.from(data_hash.replace('0x', ''), 'hex')\n      : data_hash;\n      \n    const creatorHashArray = typeof creator_hash === 'string'\n      ? Buffer.from(creator_hash.replace('0x', ''), 'hex')\n      : creator_hash;\n\n    // Create the transfer instruction (simplified to only require what's necessary)\n    const [treeAuthority] = PublicKey.findProgramAddressSync(\n      [merkleTreeAddress.toBuffer()],\n      BUBBLEGUM_PROGRAM_ID\n    );\n    \n    const transferInstruction = createTransferInstruction(\n      {\n        merkleTree: merkleTreeAddress,\n        treeAuthority: treeAuthority, // Required parameter but no signature needed\n        leafOwner: leafOwner,\n        leafDelegate: leafDelegate,\n        newLeafOwner: destinationPublicKey,\n        logWrapper: new PublicKey('nooooooooooooooooooooooooooooooooooooooo'),\n        compressionProgram: new PublicKey('cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK'),\n        anchorRemainingAccounts: [], // No additional accounts needed\n      },\n      {\n        root: rootArray,\n        dataHash: dataHashArray,\n        creatorHash: creatorHashArray,\n        nonce: BigInt(nonce),\n        index: Number(index),\n        proof: bubblegumProof,\n      },\n      BUBBLEGUM_PROGRAM_ID\n    );\n\n    // Create and sign the transaction\n    console.log('[bubblegum-transfer] Creating transaction');\n    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();\n    \n    const transaction = new Transaction({\n      feePayer: ownerAddress,\n      blockhash,\n      lastValidBlockHeight,\n    });\n\n    transaction.add(transferInstruction);\n\n    console.log('[bubblegum-transfer] Signing transaction');\n    const signedTransaction = await wallet.signTransaction(transaction);\n\n    console.log('[bubblegum-transfer] Sending transaction');\n    const signature = await connection.sendRawTransaction(signedTransaction.serialize(), {\n      skipPreflight: false,\n      preflightCommitment: 'confirmed',\n    });\n\n    console.log('[bubblegum-transfer] Waiting for confirmation');\n    const confirmation = await connection.confirmTransaction({\n      signature,\n      blockhash,\n      lastValidBlockHeight,\n    });\n\n    console.log('[bubblegum-transfer] Transaction confirmed!', signature);\n    \n    // If we got this far, transfer was successful\n    return {\n      success: true,\n      signature,\n      method: 'bubblegum',\n      assetId,\n      destination: destinationAddress,\n    };\n  } catch (error) {\n    console.error('[bubblegum-transfer] Error transferring cNFT:', error);\n    throw error;\n  }\n}\n\n// Export a helper function to determine if this transfer method can be used\nexport function canUseCompressedTransfer(assetData, proofData) {\n  if (!assetData || !assetData.compression || !assetData.compression.tree) {\n    return false;\n  }\n  \n  if (!proofData || !proofData.proof || !proofData.root) {\n    return false;\n  }\n  \n  return true;\n}"],"names":[],"sourceRoot":""}