{"version":3,"file":"static_js_bubblegum-transfer_js.js","mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAK4C;AACa;;AAEzD;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,kCAAkC,sDAAS;AAC3C,qCAAqC,sDAAS;AAC9C;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,KAAK;;AAEL;AACA;AACA,QAAQ,MAAM;AACd;AACA;AACA;AACA,QAAQ,MAAM;AACd;AACA;AACA;AACA,QAAQ,MAAM;AACd;;AAEA;AACA,4BAA4B,sDAAS;AACrC;AACA,MAAM,0EAAoB;AAC1B;AACA;AACA,gCAAgC,6FAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAS;AACjC,gCAAgC,sDAAS;AACzC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,0EAAoB;AAC1B;;AAEA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA,4BAA4B,wDAAW;AACvC;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uEAAuE,eAAe,2BAA2B,gBAAgB;AACjI;;AAEA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA,4BAA4B,wDAAW;AACvC;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,qCAAqC,sDAAS;AAC9C;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D,8BAA8B,yCAAyC;AACvE;AACA;AACA;AACA;AACA,sCAAsC,sDAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B,cAAc;AACd;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA,YAAY,SAAS,MAAM;AAC3B;AACA;AACA,YAAY;AACZ;AACA,mBAAmB,MAAM;AACzB,YAAY;AACZ;AACA,mBAAmB,MAAM;AACzB,YAAY;AACZ;AACA;AACA,mBAAmB,MAAM;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B,YAAY,SAAS,MAAM;AAC3B;AACA,YAAY;AACZ,wBAAwB,MAAM;AAC9B,YAAY;AACZ,wBAAwB,MAAM;AAC9B,YAAY;AACZ,uEAAuE,YAAY;AACnF,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA,4BAA4B,MAAM;AAClC,YAAY,SAAS,MAAM;AAC3B;AACA,YAAY;AACZ,4BAA4B,MAAM;AAClC,YAAY;AACZ,4BAA4B,MAAM;AAClC,YAAY;AACZ,4EAA4E,iBAAiB;AAC7F,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC,YAAY,SAAS,MAAM;AAC3B;AACA,YAAY;AACZ,+BAA+B,MAAM;AACrC,YAAY;AACZ,+BAA+B,MAAM;AACrC,YAAY;AACZ,+EAA+E,oBAAoB;AACnG,+BAA+B,MAAM;AACrC;AACA,UAAU;AACV;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA,gCAAgC,sDAAS;AACzC;AACA,UAAU,0EAAoB;AAC9B;AACA;AACA;AACA,oCAAoC,6FAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAS;AACrC,oCAAoC,sDAAS;AAC7C;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU,0EAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA,iFAAiF,QAAQ;AACzF,QAAQ;AACR,iEAAiE,eAAe;AAChF,4BAA4B,8CAA8C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,wBAAwB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://workspace/./static/js/bubblegum-transfer.js"],"sourcesContent":["/**\n * Bubblegum Transfer Implementation for Compressed NFTs\n * \n * This implementation follows the standard Metaplex Bubblegum protocol for transferring\n * compressed NFTs (cNFTs) on Solana. It properly handles the Merkle proofs and uses\n * the Bubblegum program to create the transfer instruction.\n * \n * NEW FEATURE:\n * Includes support for batch transfers of multiple cNFTs in a single transaction\n * which significantly reduces wallet approval friction and blockchain fees.\n */\n\nimport {\n  PROGRAM_ID as BUBBLEGUM_PROGRAM_ID,\n  createTransferInstruction,\n} from '@metaplex-foundation/mpl-bubblegum';\nimport { PublicKey, Transaction } from '@solana/web3.js';\n\n/**\n * Transfer a compressed NFT to a new owner using the Bubblegum protocol\n * \n * @param {Object} params Transfer parameters\n * @param {Connection} params.connection - Solana connection\n * @param {Object} params.wallet - User's wallet with signTransaction method\n * @param {string} params.assetId - The asset ID (mint) of the cNFT\n * @param {string} params.destinationAddress - The address to transfer the cNFT to\n * @param {Object} params.proofData - The Merkle proof data for the cNFT\n * @param {Object} params.assetData - Asset data with compression information\n * @returns {Promise<Object>} Transfer result with transaction signature\n */\nexport async function transferCompressedNFT(params) {\n  const {\n    connection,\n    wallet,\n    assetId,\n    destinationAddress,\n    proofData,\n    assetData,\n  } = params;\n\n  try {\n    console.log('[bubblegum-transfer] Starting cNFT transfer using Bubblegum protocol');\n    console.log('[bubblegum-transfer] Asset ID:', assetId);\n    console.log('[bubblegum-transfer] Destination:', destinationAddress);\n\n    if (!wallet || !wallet.publicKey || !wallet.signTransaction) {\n      throw new Error('Wallet with signTransaction capability required');\n    }\n\n    if (!proofData || !proofData.proof || !proofData.root) {\n      throw new Error('Valid proof data required for Bubblegum transfer');\n    }\n\n    if (!assetData || !assetData.compression || !assetData.compression.tree) {\n      throw new Error('Asset compression data required for Bubblegum transfer');\n    }\n\n    // Extract proof data\n    const {\n      root,\n      proof,\n      leaf_id,\n      leaf,\n      data_hash,\n      creator_hash,\n    } = proofData;\n\n    // Get necessary addresses and data\n    const ownerAddress = wallet.publicKey;\n    const merkleTreeAddress = new PublicKey(assetData.compression.tree);\n    const destinationPublicKey = new PublicKey(destinationAddress);\n    const leafOwner = ownerAddress;\n    const leafDelegate = ownerAddress; // Assuming owner is also delegate\n    const nonce = assetData.compression.leaf_id || leaf_id;\n    const index = assetData.compression.leaf_id || leaf_id;\n\n    console.log('[bubblegum-transfer] Creating Bubblegum transfer instruction');\n    console.log('[bubblegum-transfer] Merkle tree:', merkleTreeAddress.toString());\n    console.log('[bubblegum-transfer] Owner:', ownerAddress.toString());\n    console.log('[bubblegum-transfer] Destination:', destinationPublicKey.toString());\n\n    // Convert proof to right format if needed\n    const bubblegumProof = proof.map(node => {\n      if (typeof node === 'string') {\n        return Buffer.from(node.replace('0x', ''), 'hex');\n      }\n      return node;\n    });\n\n    // Set up root and hashes in the right format\n    const rootArray = typeof root === 'string' \n      ? Buffer.from(root.replace('0x', ''), 'hex') \n      : root;\n      \n    const dataHashArray = typeof data_hash === 'string'\n      ? Buffer.from(data_hash.replace('0x', ''), 'hex')\n      : data_hash;\n      \n    const creatorHashArray = typeof creator_hash === 'string'\n      ? Buffer.from(creator_hash.replace('0x', ''), 'hex')\n      : creator_hash;\n\n    // Create the transfer instruction (simplified to only require what's necessary)\n    const [treeAuthority] = PublicKey.findProgramAddressSync(\n      [merkleTreeAddress.toBuffer()],\n      BUBBLEGUM_PROGRAM_ID\n    );\n    \n    const transferInstruction = createTransferInstruction(\n      {\n        merkleTree: merkleTreeAddress,\n        treeAuthority: treeAuthority, // Required parameter but no signature needed\n        leafOwner: leafOwner,\n        leafDelegate: leafDelegate,\n        newLeafOwner: destinationPublicKey,\n        logWrapper: new PublicKey('nooooooooooooooooooooooooooooooooooooooo'),\n        compressionProgram: new PublicKey('cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK'),\n        anchorRemainingAccounts: [], // No additional accounts needed\n      },\n      {\n        root: rootArray,\n        dataHash: dataHashArray,\n        creatorHash: creatorHashArray,\n        nonce: BigInt(nonce),\n        index: Number(index),\n        proof: bubblegumProof,\n      },\n      BUBBLEGUM_PROGRAM_ID\n    );\n\n    // Create and sign the transaction\n    console.log('[bubblegum-transfer] Creating transaction');\n    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();\n    \n    const transaction = new Transaction({\n      feePayer: ownerAddress,\n      blockhash,\n      lastValidBlockHeight,\n    });\n\n    transaction.add(transferInstruction);\n\n    console.log('[bubblegum-transfer] Signing transaction');\n    const signedTransaction = await wallet.signTransaction(transaction);\n\n    console.log('[bubblegum-transfer] Sending transaction');\n    const signature = await connection.sendRawTransaction(signedTransaction.serialize(), {\n      skipPreflight: false,\n      preflightCommitment: 'confirmed',\n    });\n\n    console.log('[bubblegum-transfer] Waiting for confirmation');\n    const confirmation = await connection.confirmTransaction({\n      signature,\n      blockhash,\n      lastValidBlockHeight,\n    });\n\n    console.log('[bubblegum-transfer] Transaction confirmed!', signature);\n    \n    // If we got this far, transfer was successful\n    return {\n      success: true,\n      signature,\n      method: 'bubblegum',\n      assetId,\n      destination: destinationAddress,\n    };\n  } catch (error) {\n    console.error('[bubblegum-transfer] Error transferring cNFT:', error);\n    throw error;\n  }\n}\n\n/**\n * Batch transfer multiple compressed NFTs in a single transaction\n * This reduces wallet approval friction and saves on transaction fees\n * \n * @param {Object} params - Batch transfer parameters\n * @param {Connection} params.connection - Solana connection\n * @param {Object} params.wallet - User's wallet with signTransaction method\n * @param {Array} params.assets - Array of assets to transfer, each containing:\n *   - assetId: The asset ID (mint) of the cNFT\n *   - assetData: The asset data with compression info\n *   - proofData: The merkle proof data\n * @param {string} params.destinationAddress - The destination wallet address\n * @returns {Promise<Object>} - Result with transaction signature and success status\n */\nexport async function batchTransferCompressedNFTs(params) {\n  const {\n    connection,\n    wallet,\n    assets,\n    destinationAddress\n  } = params;\n\n  try {\n    console.log('[bubblegum-transfer] Starting batch cNFT transfer using Bubblegum protocol');\n    console.log('[bubblegum-transfer] Number of assets:', assets.length);\n    console.log('[bubblegum-transfer] Destination:', destinationAddress);\n\n    if (!wallet || !wallet.publicKey || !wallet.signTransaction) {\n      throw new Error('Wallet with signTransaction capability required');\n    }\n\n    if (!assets || !Array.isArray(assets) || assets.length === 0) {\n      throw new Error('At least one valid asset is required for batch transfer');\n    }\n\n    // Validate maximum batch size (too many will exceed transaction size limits)\n    const MAX_BATCH_SIZE = 5;\n    if (assets.length > MAX_BATCH_SIZE) {\n      console.warn(`[bubblegum-transfer] Batch size exceeds maximum (${MAX_BATCH_SIZE}). Only processing first ${MAX_BATCH_SIZE} assets.`);\n    }\n\n    const assetsToProcess = assets.slice(0, MAX_BATCH_SIZE);\n    \n    // Create a new transaction\n    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();\n    \n    const transaction = new Transaction({\n      feePayer: wallet.publicKey,\n      blockhash,\n      lastValidBlockHeight,\n    });\n\n    // Prepare each cNFT transfer instruction\n    const processedAssets = [];\n    const failedAssets = [];\n\n    // Common destination address\n    const destinationPublicKey = new PublicKey(destinationAddress);\n    \n    // Create transfer instruction for each asset\n    for (const asset of assetsToProcess) {\n      try {\n        const { assetId, assetData, proofData } = asset;\n        \n        // Validate required data\n        if (!canUseCompressedTransfer(assetData, proofData)) {\n          console.warn(`[bubblegum-transfer] Asset ${assetId} missing required data for Bubblegum transfer`);\n          failedAssets.push({ assetId, error: 'Missing required data' });\n          continue;\n        }\n        \n        // Get merkle tree address\n        const merkleTreeAddress = new PublicKey(assetData.compression.tree);\n        \n        // Extract proof data\n        const {\n          root,\n          proof,\n          data_hash,\n          creator_hash,\n        } = proofData;\n        \n        const leafId = assetData.compression.leaf_id || proofData.leaf_id;\n        \n        // Owner and delegate are the same (current wallet)\n        const ownerAddress = wallet.publicKey;\n        const leafOwner = ownerAddress;\n        const leafDelegate = ownerAddress;\n        \n        // Convert proof to correct format\n        const bubblegumProof = proof.map(node => {\n          // Convert string proofs to Buffer\n          if (typeof node === 'string') {\n            try {\n              // Remove '0x' prefix if present\n              const cleanNode = node.replace('0x', '');\n              // Create Buffer from hex string\n              return Buffer.from(cleanNode, 'hex');\n            } catch (err) {\n              console.error(`[bubblegum-transfer] Error converting proof node to Buffer:`, err);\n              // Return a safe default if conversion fails\n              return Buffer.from([]);\n            }\n          } else if (Buffer.isBuffer(node)) {\n            // If already a Buffer, return as is\n            return node;\n          } else if (Array.isArray(node)) {\n            // If it's an array (like Uint8Array), convert to Buffer\n            return Buffer.from(node);\n          } else if (node && typeof node === 'object' && node.type === 'Buffer' && Array.isArray(node.data)) {\n            // Handle special case of serialized Buffer objects\n            return Buffer.from(node.data);\n          } else {\n            console.warn(`[bubblegum-transfer] Unknown proof node type:`, typeof node);\n            // Return an empty buffer as fallback\n            return Buffer.from([]);\n          }\n        });\n        \n        // Safely convert root and hashes to Buffer format\n        let rootArray, dataHashArray, creatorHashArray;\n        \n        try {\n          // Handle root conversion\n          if (typeof root === 'string') {\n            rootArray = Buffer.from(root.replace('0x', ''), 'hex');\n          } else if (Buffer.isBuffer(root)) {\n            rootArray = root;\n          } else if (Array.isArray(root)) {\n            rootArray = Buffer.from(root);\n          } else if (root && typeof root === 'object' && root.type === 'Buffer' && Array.isArray(root.data)) {\n            rootArray = Buffer.from(root.data);\n          } else {\n            console.warn(`[bubblegum-transfer] Unexpected root type: ${typeof root}`);\n            rootArray = Buffer.from([]);\n          }\n          \n          // Handle data_hash conversion\n          if (typeof data_hash === 'string') {\n            dataHashArray = Buffer.from(data_hash.replace('0x', ''), 'hex');\n          } else if (Buffer.isBuffer(data_hash)) {\n            dataHashArray = data_hash;\n          } else if (Array.isArray(data_hash)) {\n            dataHashArray = Buffer.from(data_hash);\n          } else if (data_hash && typeof data_hash === 'object' && data_hash.type === 'Buffer' && Array.isArray(data_hash.data)) {\n            dataHashArray = Buffer.from(data_hash.data);\n          } else {\n            console.warn(`[bubblegum-transfer] Unexpected data_hash type: ${typeof data_hash}`);\n            dataHashArray = Buffer.from([]);\n          }\n          \n          // Handle creator_hash conversion\n          if (typeof creator_hash === 'string') {\n            creatorHashArray = Buffer.from(creator_hash.replace('0x', ''), 'hex');\n          } else if (Buffer.isBuffer(creator_hash)) {\n            creatorHashArray = creator_hash;\n          } else if (Array.isArray(creator_hash)) {\n            creatorHashArray = Buffer.from(creator_hash);\n          } else if (creator_hash && typeof creator_hash === 'object' && creator_hash.type === 'Buffer' && Array.isArray(creator_hash.data)) {\n            creatorHashArray = Buffer.from(creator_hash.data);\n          } else {\n            console.warn(`[bubblegum-transfer] Unexpected creator_hash type: ${typeof creator_hash}`);\n            creatorHashArray = Buffer.from([]);\n          }\n        } catch (error) {\n          console.error(`[bubblegum-transfer] Error converting hash data:`, error);\n          throw new Error(`Failed to convert hash data: ${error.message}`);\n        }\n        \n        // Derive tree authority\n        const [treeAuthority] = PublicKey.findProgramAddressSync(\n          [merkleTreeAddress.toBuffer()],\n          BUBBLEGUM_PROGRAM_ID\n        );\n        \n        // Create transfer instruction\n        const transferInstruction = createTransferInstruction(\n          {\n            merkleTree: merkleTreeAddress,\n            treeAuthority: treeAuthority,\n            leafOwner: leafOwner,\n            leafDelegate: leafDelegate,\n            newLeafOwner: destinationPublicKey,\n            logWrapper: new PublicKey('nooooooooooooooooooooooooooooooooooooooo'),\n            compressionProgram: new PublicKey('cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK'),\n            anchorRemainingAccounts: [],\n          },\n          {\n            root: rootArray,\n            dataHash: dataHashArray,\n            creatorHash: creatorHashArray,\n            nonce: BigInt(leafId),\n            index: Number(leafId),\n            proof: bubblegumProof,\n          },\n          BUBBLEGUM_PROGRAM_ID\n        );\n        \n        // Add the instruction to the transaction\n        transaction.add(transferInstruction);\n        \n        // Track this asset as processed\n        processedAssets.push({ assetId, assetData });\n        \n        console.log(`[bubblegum-transfer] Added transfer instruction for asset ${assetId}`);\n      } catch (error) {\n        console.error(`[bubblegum-transfer] Error adding asset ${asset.assetId} to batch:`, error);\n        failedAssets.push({ assetId: asset.assetId, error: error.message });\n      }\n    }\n    \n    // If no assets were successfully added to the transaction, return failure\n    if (processedAssets.length === 0) {\n      return {\n        success: false,\n        error: 'Could not add any assets to the batch transaction',\n        failedAssets\n      };\n    }\n    \n    // Sign and send the transaction\n    console.log(`[bubblegum-transfer] Signing batch transaction with ${processedAssets.length} assets`);\n    const signedTransaction = await wallet.signTransaction(transaction);\n    \n    console.log('[bubblegum-transfer] Sending batch transaction');\n    const signature = await connection.sendRawTransaction(signedTransaction.serialize(), {\n      skipPreflight: false,\n      preflightCommitment: 'confirmed',\n    });\n    \n    console.log('[bubblegum-transfer] Waiting for batch transaction confirmation');\n    const confirmation = await connection.confirmTransaction({\n      signature,\n      blockhash,\n      lastValidBlockHeight,\n    });\n    \n    if (confirmation.value.err) {\n      console.error('[bubblegum-transfer] Batch transaction error:', confirmation.value.err);\n      return {\n        success: false,\n        error: `Transaction failed: ${confirmation.value.err}`,\n        signature,\n        processedAssets,\n        failedAssets\n      };\n    }\n    \n    console.log('[bubblegum-transfer] Batch transaction confirmed!', signature);\n    \n    // Return success with details\n    return {\n      success: true,\n      signature,\n      method: 'bubblegum-batch',\n      processedAssets: processedAssets.map(a => a.assetId),\n      failedAssets: failedAssets.map(a => a.assetId),\n      explorerUrl: `https://solscan.io/tx/${signature}`,\n      destination: destinationAddress\n    };\n  } catch (error) {\n    console.error('[bubblegum-transfer] Error in batch transfer:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown error in batch transfer',\n      cancelled: error.message && (\n        error.message.includes('User rejected') ||\n        error.message.includes('cancelled') ||\n        error.message.includes('declined')\n      )\n    };\n  }\n}\n\n// Export a helper function to determine if this transfer method can be used\nexport function canUseCompressedTransfer(assetData, proofData) {\n  // Detailed validation with specific error logging to help troubleshoot\n  \n  // First validate asset data is properly structured\n  if (!assetData) {\n    console.warn('[bubblegum-transfer] Missing asset data for compressed transfer');\n    return false;\n  }\n  \n  if (!assetData.compression) {\n    console.warn('[bubblegum-transfer] Asset is not compressed (missing compression field)');\n    return false;\n  }\n  \n  if (!assetData.compression.tree) {\n    console.warn('[bubblegum-transfer] Asset missing merkle tree address');\n    return false;\n  }\n  \n  if (assetData.compression.leaf_id === undefined || assetData.compression.leaf_id === null) {\n    console.warn('[bubblegum-transfer] Asset missing leaf ID in compression data');\n    // Not returning false here because we can sometimes get leaf ID from proof data\n  }\n  \n  // Then validate proof data structure\n  if (!proofData) {\n    console.warn('[bubblegum-transfer] Missing proof data for compressed transfer');\n    return false;\n  }\n  \n  if (!proofData.proof || !Array.isArray(proofData.proof)) {\n    console.warn('[bubblegum-transfer] Missing or invalid proof array in proof data');\n    return false;\n  }\n  \n  if (!proofData.root) {\n    console.warn('[bubblegum-transfer] Missing root in proof data');\n    return false;\n  }\n  \n  if (!proofData.data_hash) {\n    console.warn('[bubblegum-transfer] Missing data_hash in proof data');\n    return false;\n  }\n  \n  if (!proofData.creator_hash) {\n    console.warn('[bubblegum-transfer] Missing creator_hash in proof data');\n    return false;\n  }\n  \n  // All validation passed\n  return true;\n}"],"names":[],"sourceRoot":""}