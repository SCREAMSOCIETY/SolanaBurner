<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Solana Token Burner</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <style>
        .collection-section {
            background: rgba(153, 69, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .collection-header {
            color: #9945FF;
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #9945FF;
        }

        .collection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Solana Token Burner</h1>
        <div class="wallet-section">
            <button id="connectButton" class="connect-button">
                <img src="{{ url_for('static', filename='phantom.svg') }}" alt="Phantom" class="wallet-icon">
                Connect Phantom
            </button>
            <div id="walletInfo" class="connected-status" style="display: none;">
                <div>Wallet Connected</div>
                <div id="walletAddress" class="wallet-address"></div>
            </div>
        </div>
        <div id="statusMessage" style="display: none;" class="status-message"></div>

        <template id="token-card-template">
            <div class="asset-card token-card">
                <div class="selection-overlay">
                    <input type="checkbox" class="asset-selector" aria-label="Select asset for burning">
                </div>
                <div class="token-header">
                    <div class="token-icon-wrapper">
                        <img class="token-icon" src="" alt="Token Icon" loading="lazy" />
                    </div>
                    <div class="token-info">
                        <h4 class="token-name"></h4>
                        <span class="token-symbol"></span>
                    </div>
                </div>
                <div class="token-details">
                    <div class="token-balance">
                        <span class="balance-label">Balance:</span>
                        <span class="balance-amount"></span>
                    </div>
                </div>
                <div class="token-actions">
                    <input type="number" class="burn-amount" placeholder="Amount to burn" step="0.000001" />
                    <button class="burn-button">Burn Token</button>
                </div>
                <div class="links-container">
                    <a class="solscan-link" href="" target="_blank">View on Solscan</a>
                </div>
            </div>
        </template>

        <template id="nft-card-template">
            <div class="asset-card nft-card">
                <div class="selection-overlay">
                    <input type="checkbox" class="asset-selector" aria-label="Select NFT for burning">
                </div>
                <div class="nft-image-wrapper">
                    <img class="nft-image" src="" alt="NFT" loading="lazy" />
                </div>
                <div class="nft-info">
                    <h4 class="nft-name"></h4>
                    <p class="nft-collection"></p>
                </div>
                <div class="token-actions">
                    <button class="burn-button">Burn NFT</button>
                </div>
                <div class="links-container">
                    <a class="solscan-link" href="" target="_blank">View on Solscan</a>
                </div>
            </div>
        </template>

        <template id="cnft-card-template">
            <div class="asset-card cnft-card">
                <div class="cnft-image-wrapper">
                    <img class="cnft-image" src="" alt="cNFT" loading="lazy" />
                </div>
                <div class="cnft-info">
                    <h4 class="cnft-name"></h4>
                    <p class="cnft-collection"></p>
                </div>
            </div>
        </template>

        <div id="assetsContainer" class="assets-container" style="display: none;">
            <h2>Your Assets</h2>
            <div class="tabs">
                <button class="tab-button active" data-tab="tokens">Tokens</button>
                <button class="tab-button" data-tab="nfts">NFTs</button>
                <button class="tab-button" data-tab="cnfts">cNFTs</button>
            </div>
            <div id="loadingMessage" class="loading-message" style="display: none;">Loading assets...</div>
            <div id="errorMessage" class="error-message" style="display: none;"></div>

            <div class="bulk-actions-bar" style="display: none;">
                <div class="selected-count">0 items selected</div>
                <div class="bulk-actions">
                    <button class="bulk-burn-button">Burn Selected</button>
                    <button class="clear-selection">Clear Selection</button>
                </div>
            </div>

            <div class="tab-content">
                <div id="tokens" class="tab-panel active">
                    <div class="assets-grid"></div>
                </div>
                <div id="nfts" class="tab-panel">
                    <div class="collections-grid"></div>
                </div>
                <div id="cnfts" class="tab-panel">
                    <div class="assets-grid"></div>
                </div>
            </div>
        </div>

        <div id="achievementsContainer" class="achievements-container" style="display: none;">
            <h2>Achievements</h2>
            <div class="achievements-grid">
            </div>
        </div>

        <template id="achievement-card-template">
            <div class="achievement-card">
                <div class="achievement-icon">
                    <svg class="achievement-svg" viewBox="0 0 24 24" width="48" height="48">
                    </svg>
                </div>
                <div class="achievement-info">
                    <h3 class="achievement-title"></h3>
                    <p class="achievement-description"></p>
                </div>
                <div class="achievement-progress">
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                    <span class="progress-text"></span>
                </div>
            </div>
        </template>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            console.log("Initializing wallet handler...");

            const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');

            const connectButton = document.getElementById('connectButton');
            const walletInfo = document.getElementById('walletInfo');
            const walletAddress = document.getElementById('walletAddress');
            const statusMessage = document.getElementById('statusMessage');
            const assetsContainer = document.getElementById('assetsContainer');
            const loadingMessage = document.getElementById('loadingMessage');
            const errorMessage = document.getElementById('errorMessage');

            let currentWallet = null;
            let connection = null;

            function showStatus(message, isError = false) {
                statusMessage.textContent = message;
                statusMessage.style.display = 'block';
                statusMessage.className = `status-message ${isError ? 'error' : 'success'}`;
                console.log(`Status: ${message}`);
            }

            function showLoading(show = true) {
                loadingMessage.style.display = show ? 'block' : 'none';
                if (show) {
                    errorMessage.style.display = 'none';
                }
            }

            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
                loadingMessage.style.display = 'none';
                console.error('Error:', message);
            }

            function getConnection() {
                const endpoint = '{{ rpc_endpoint }}';
                console.log('Using RPC endpoint:', endpoint);
                return new solanaWeb3.Connection(endpoint, {
                    commitment: 'confirmed',
                    wsEndpoint: false
                });
            }

            async function connectWallet() {
                try {
                    // Check if Phantom is installed
                    if (!window.solana || !window.solana.isPhantom) {
                        showStatus('Phantom wallet not found. Please install Phantom.', true);
                        window.open('https://phantom.app/', '_blank');
                        return;
                    }

                    // First disconnect if already connected
                    if (currentWallet && currentWallet.isConnected) {
                        await currentWallet.disconnect();
                    }

                    showStatus('Connecting to Phantom...');

                    // Request connection
                    const resp = await window.solana.connect();

                    if (resp.publicKey) {
                        const address = resp.publicKey.toString();
                        console.log('Connected to wallet:', address);

                        currentWallet = window.solana;
                        connection = getConnection();

                        connectButton.style.display = 'none';
                        walletInfo.style.display = 'block';
                        walletAddress.textContent = `Address: ${address.slice(0,6)}...${address.slice(-6)}`;
                        assetsContainer.style.display = 'block';

                        showStatus('Wallet connected successfully');
                        await loadAssets(address);

                        // Trigger achievements
                        updateAchievement('FIRST_CONNECTION');
                        updateAchievement('ASSET_VIEWER');
                    }
                } catch (error) {
                    console.error('Connection error:', error);
                    showStatus(`Failed to connect: ${error.message}`, true);

                    // Reset connection state
                    currentWallet = null;
                    connection = null;
                    connectButton.style.display = 'block';
                    walletInfo.style.display = 'none';
                    assetsContainer.style.display = 'none';
                }
            }

            // Add event listeners for wallet status changes
            if (window.solana) {
                window.solana.on('connect', () => {
                    console.log('Wallet connected event received');
                });

                window.solana.on('disconnect', () => {
                    console.log('Wallet disconnected event received');
                    currentWallet = null;
                    connection = null;
                    connectButton.style.display = 'block';
                    walletInfo.style.display = 'none';
                    assetsContainer.style.display = 'none';
                    showStatus('Wallet disconnected');
                });
            }

            connectButton.addEventListener('click', connectWallet);

            // Check if wallet is already connected
            if (window.solana && window.solana.isPhantom && window.solana.isConnected) {
                console.log('Wallet already connected, reconnecting...');
                connectWallet();
            }

            function setupIntelligentImageLoading(imgElement, primaryUrl, type = 'token') {
                imgElement.classList.add('loading');

                const defaultImages = {
                    'token': '{{ url_for('static', filename='default-token-icon.svg') }}',
                    'nft': '{{ url_for('static', filename='default-nft-image.svg') }}',
                    'cnft': '{{ url_for('static', filename='default-nft-image.svg') }}'
                };

                const ipfsGateways = [
                    'https://ipfs.io/ipfs/',
                    'https://gateway.pinata.cloud/ipfs/',
                    'https://cloudflare-ipfs.com/ipfs/',
                    'https://gateway.ipfs.io/ipfs/'
                ];

                async function tryLoadImage(url) {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(url);
                        img.onerror = () => reject();
                        img.src = url;
                    });
                }

                async function loadWithFallback() {
                    if (!primaryUrl) {
                        imgElement.src = defaultImages[type];
                        imgElement.classList.remove('loading');
                        return;
                    }

                    try {
                        await tryLoadImage(primaryUrl);
                        imgElement.src = primaryUrl;
                    } catch {
                        if (primaryUrl.startsWith('ipfs://')) {
                            const hash = primaryUrl.replace('ipfs://', '');
                            let loaded = false;

                            for (const gateway of ipfsGateways) {
                                try {
                                    const url = gateway + hash;
                                    await tryLoadImage(url);
                                    imgElement.src = url;
                                    loaded = true;
                                    break;
                                } catch {
                                    continue;
                                }
                            }

                            if (!loaded) {
                                imgElement.src = defaultImages[type];
                            }
                        } else {
                            imgElement.src = defaultImages[type];
                        }
                    }

                    imgElement.classList.remove('loading');
                }

                loadWithFallback();
            }

            function formatAddress(address) {
                return `${address.slice(0, 4)}...${address.slice(-4)}`;
            }

            function getDisplayName(asset, type = 'token') {
                if (type === 'token') {
                    // For tokens, try name + symbol if available
                    if (asset.name && asset.symbol) {
                        return `${asset.name} (${asset.symbol})`;
                    } else if (asset.name) {
                        return asset.name;
                    } else if (asset.symbol) {
                        return asset.symbol;
                    }
                } else if (type === 'nft') {
                    // For NFTs, try name + collection
                    if (asset.name && asset.collection) {
                        return `${asset.name} - ${asset.collection}`;
                    } else if (asset.name) {
                        return asset.name;
                    } else if (asset.collection) {
                        return `NFT from ${asset.collection}`;
                    }
                }
                // Fallback to formatted address
                return `${type === 'token' ? 'Token' : 'NFT'} ${formatAddress(asset.mint)}`;
            }

            function createTokenCard(token) {
                const template = document.querySelector('#token-card-template');
                const card = template.content.cloneNode(true);
                const cardElement = card.querySelector('.asset-card');
                cardElement.dataset.mint = token.mint;

                const iconElem = card.querySelector('.token-icon');
                setupIntelligentImageLoading(iconElem, token.icon, 'token');

                const displayName = getDisplayName(token, 'token');
                card.querySelector('.token-name').textContent = displayName;
                card.querySelector('.token-symbol').textContent = token.symbol || formatAddress(token.mint);
                card.querySelector('.balance-amount').textContent = formatNumber(token.amount);

                card.querySelector('.solscan-link').href = `https://solscan.io/token/${token.mint}`;

                const burnInput = card.querySelector('.burn-amount');
                burnInput.max = token.amount;
                burnInput.min = 0.000001;

                const burnButton = card.querySelector('.burn-button');
                burnButton.dataset.mint = token.mint;
                burnButton.dataset.decimals = token.decimals;

                setupBurnButton(burnButton, burnInput, token);
                setupAssetSelection(card, token, displayName);

                return card;
            }

            function createNFTCard(nft) {
                const template = document.querySelector('#nft-card-template');
                const card = template.content.cloneNode(true);
                const cardElement = card.querySelector('.asset-card');
                cardElement.dataset.mint = nft.mint;

                const imageElem = card.querySelector('.nft-image');
                setupIntelligentImageLoading(imageElem, nft.image, 'nft');

                const displayName = getDisplayName(nft, 'nft');
                card.querySelector('.nft-name').textContent = displayName;
                card.querySelector('.nft-collection').textContent = nft.collection || '';
                card.querySelector('.solscan-link').href = `https://solscan.io/token/${nft.mint}`;

                const burnButton = card.querySelector('.burn-button');
                burnButton.dataset.mint = nft.mint;

                burnButton.addEventListener('click', async () => {
                    if (!confirm(`Are you sure you want to burn this NFT (${displayName})? This action cannot be undone.`)) {
                        return;
                    }

                    try {
                        showLoading(true);
                        const result = await burnToken(nft.mint, 1, 0);
                        if (result) {
                            showStatus('NFT burned successfully');
                            card.classList.add('burned');
                            setTimeout(() => {
                                card.remove();
                            }, 500);
                        }
                    } catch (error) {
                        showError(`Failed to burn NFT: ${error.message}`);
                    } finally {
                        showLoading(false);
                    }
                });

                const selector = card.querySelector('.asset-selector');
                selector.addEventListener('change', (e) => {
                    const isSelected = e.target.checked;
                    const card = e.target.closest('.asset-card');

                    if (isSelected) {
                        selectedAssets.set(nft.mint, {
                            type: 'nft',
                            amount: 1,
                            decimals: 0,
                            displayName: displayName
                        });
                        card.classList.add('selected');
                    } else {
                        selectedAssets.delete(nft.mint);
                        card.classList.remove('selected');
                    }

                    updateBulkActionsBar();
                });

                return card;
            }

            function createCNFTCard(cnft) {
                const template = document.querySelector('#cnft-card-template');
                const card = template.content.cloneNode(true);

                const imageElem = card.querySelector('.cnft-image');
                setupIntelligentImageLoading(imageElem, cnft.image, 'cnft');

                card.querySelector('.cnft-name').textContent = cnft.name || 'Unnamed cNFT';
                card.querySelector('.cnft-collection').textContent = cnft.collection || '';

                return card;
            }

            function displayNFTs(nfts) {
                const nftsContainer = document.querySelector('#nfts .collections-grid');
                nftsContainer.innerHTML = '';

                if (!nfts || nfts.length === 0) {
                    nftsContainer.innerHTML = '<div class="no-assets">No NFTs found</div>';
                    return;
                }

                // Group NFTs by collection
                const nftsByCollection = nfts.reduce((acc, nft) => {
                    const collection = nft.collection || 'Other';
                    if (!acc[collection]) {
                        acc[collection] = [];
                    }
                    acc[collection].push(nft);
                    return acc;
                }, {});

                // Sort collections alphabetically
                const sortedCollections = Object.keys(nftsByCollection).sort((a, b) => {
                    if (a === 'Other') return 1;
                    if (b === 'Other') return -1;
                    return a.localeCompare(b);
                });

                // Create sections for each collection
                sortedCollections.forEach(collection => {
                    const collectionSection = document.createElement('div');
                    collectionSection.className = 'collection-section';

                    const header = document.createElement('div');
                    header.className = 'collection-header';
                    header.textContent = collection;
                    collectionSection.appendChild(header);

                    const grid = document.createElement('div');
                    grid.className = 'collection-grid';

                    // Sort NFTs within collection by name
                    const sortedNFTs = nftsByCollection[collection].sort((a, b) => {
                        return (a.name || '').localeCompare(b.name || '');
                    });

                    sortedNFTs.forEach(nft => {
                        const card = createNFTCard(nft);
                        grid.appendChild(card);
                    });

                    collectionSection.appendChild(grid);
                    nftsContainer.appendChild(collectionSection);
                });
            }

            async function loadAssets(publicKey) {
                showLoading(true);
                document.querySelectorAll('.assets-grid, .collections-grid').forEach(grid => {
                    grid.innerHTML = '';
                    grid.style.display = 'none';
                });

                try {
                    const response = await fetch(`/assets?wallet=${publicKey}`);
                    const data = await response.json();

                    if (!data.success) {
                        throw new Error(data.message || 'Failed to fetch assets');
                    }

                    const assets = data.assets;
                    const tokensGrid = document.querySelector('#tokens .assets-grid');

                    if (!assets.tokens || assets.tokens.length === 0) {
                        tokensGrid.innerHTML = '<div class="no-assets">No tokens found</div>';
                    } else {
                        assets.tokens.forEach(token => {
                            const card = createTokenCard(token);
                            tokensGrid.appendChild(card);
                        });
                    }

                    // Use the new displayNFTs function
                    displayNFTs(assets.nfts);

                    const cnftsGrid = document.querySelector('#cnfts .assets-grid');
                    if (!assets.cnfts || assets.cnfts.length === 0) {
                        cnftsGrid.innerHTML = '<div class="no-assets">No cNFTs found</div>';
                    } else {
                        assets.cnfts.forEach(cnft => {
                            const card = createCNFTCard(cnft);
                            cnftsGrid.appendChild(card);
                        });
                    }

                    showLoading(false);
                    document.querySelectorAll('.assets-grid, .collections-grid').forEach(grid => {
                        grid.style.display = 'grid';
                    });

                } catch (error) {
                    console.error('Error loading assets:', error);
                    showError(`Failed to load assets: ${error.message}`);
                }
            }






            function formatNumber(num) {
                return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 6
                }).format(num);
            }

            function validateBurnAmount(input, maxAmount) {
                const amount = parseFloat(input.value);
                console.log('Validating burn amount:', amount, 'max:', maxAmount);

                if (isNaN(amount) || amount <= 0) {
                    showError('Please enter a valid amount greater than 0');
                    return false;
                }

                if (amount - maxAmount > Number.EPSILON) {
                    showError(`Amount cannot exceed ${maxAmount}`);
                    return false;
                }

                return true;
            }

            async function burnToken(mint, amount, decimals) {
                const mintPubkey = new solanaWeb3.PublicKey(mint);
                const walletPubkey = currentWallet.publicKey;

                console.log(`Creating burn instruction for ${mint}`);
                console.log(`- Amount: ${amount}`);
                console.log(`- Decimals: ${decimals}`);

                const effectiveDecimals = decimals;
                const multiplier = BigInt(10 ** effectiveDecimals);
                const rawAmount = BigInt(Math.round(amount * Number(multiplier)));

                if (rawAmount <= BigInt(0)) {
                    throw new Error('Amount must be greater than 0');
                }

                const [tokenAccountPubkey] = await solanaWeb3.PublicKey.findProgramAddress(
                    [
                        walletPubkey.toBuffer(),
                        TOKEN_PROGRAM_ID.toBuffer(),
                        mintPubkey.toBuffer(),
                    ],
                    new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL')
                );

                // Create burn instruction
                const burnIx = createBurnInstruction(
                    tokenAccountPubkey,
                    mintPubkey,
                    walletPubkey,
                    rawAmount
                );

                // Only include close instruction for NFTs (decimals === 0)
                if (decimals === 0) {
                    const closeIx = new solanaWeb3.TransactionInstruction({
                        keys: [
                            { pubkey: tokenAccountPubkey, isSigner: false, isWritable: true },
                            { pubkey: walletPubkey, isSigner: false, isWritable: true },
                            { pubkey: walletPubkey, isSigner: true, isWritable: false },
                        ],
                        programId: TOKEN_PROGRAM_ID,
                        data: new Uint8Array([9]) // Close account instruction
                    });
                    return [burnIx, closeIx];
                }

                return [burnIx];
            }

            function createBurnInstruction(tokenAccount, mint, owner, amount) {
                const dataLayout = new Uint8Array(9);
                dataLayout[0] = 8; // Burn instruction
                const amountBytes = new Uint8Array(8);
                const view = new DataView(amountBytes.buffer);
                view.setBigUint64(0, amount, true);
                dataLayout.set(amountBytes, 1);

                return new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: tokenAccount, isSigner: false, isWritable: true },
                        { pubkey: mint, isSigner: false, isWritable: true },
                        { pubkey: owner, isSigner: true, isWritable: false },
                    ],
                    programId: TOKEN_PROGRAM_ID,
                    data: dataLayout
                });
            }


            // Add tab switching functionality back
            const tabs = document.querySelectorAll('.tab-button');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    console.log('Tab clicked:', tab.dataset.tab);
                    tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));

                    tab.classList.add('active');
                    const panel = document.getElementById(tab.dataset.tab);
                    if (panel) {
                        panel.classList.add('active');
                    }
                });
            });

            // Add bulk selection state
            let selectedAssets = new Map(); // Map of selected assets: mint -> {type, amount}
            const bulkActionsBar = document.querySelector('.bulk-actions-bar');
            const selectedCountDisplay = document.querySelector('.selected-count');
            const bulkBurnButton = document.querySelector('.bulk-burn-button');
            const clearSelectionButton = document.querySelector('.clear-selection');

            function updateBulkActionsBar() {
                const count = selectedAssets.size;
                if (count > 0) {
                    selectedCountDisplay.textContent = `${count} item${count === 1 ? '' : 's'} selected`;
                    bulkActionsBar.style.display = 'flex';
                } else {
                    bulkActionsBar.style.display = 'none';
                }
            }

            function clearSelection() {
                selectedAssets.clear();
                document.querySelectorAll('.asset-selector').forEach(checkbox => {
                    checkbox.checked = false;
                    checkbox.closest('.asset-card').classList.remove('selected');
                });
                updateBulkActionsBar();
            }

            async function burnSelectedAssets() {
                if (selectedAssets.size === 0) {
                    showError('No assets selected for burning');
                    return;
                }

                // Create a summary of selected assets
                let summary = 'You are about to burn:\n';
                for (const [mint, asset] of selectedAssets) {
                    const amount = asset.type === 'nft' ? '1' : asset.amount;
                    summary += `\n- ${asset.displayName}: ${amount}`;
                }

                if (!confirm(`${summary}\n\nThis action cannot be undone. Do you want to continue?`)) {
                    return;
                }

                try {
                    showLoading(true);
                    const instructions = [];

                    // Create burn instructions for each selected asset
                    for (const [mint, asset] of selectedAssets) {
                        const burnInstructions = await burnToken(mint, asset.amount, asset.decimals);
                        instructions.push(...burnInstructions);
                    }

                    // Create and send transaction
                    const latestBlockhash = await connection.getLatestBlockhash();
                    const transaction = new solanaWeb3.Transaction({
                        feePayer: currentWallet.publicKey,
                        ...latestBlockhash,
                    });

                    transaction.add(...instructions);

                    const signed = await currentWallet.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(signed.serialize());
                    await connection.confirmTransaction(signature);

                    showStatus('Assets burned successfully');

                    // Remove burned assets from display
                    for (const [mint] of selectedAssets) {
                        const card = document.querySelector(`.asset-card[data-mint="${mint}"]`);
                        if (card) {
                            card.classList.add('burned');
                            setTimeout(() => {
                                card.remove();
                            }, 500);
                        }
                    }

                    // Clear selection
                    clearSelection();
                } catch (error) {
                    showError(`Failed to burn assets: ${error.message}`);
                } finally {
                    showLoading(false);
                }
            }

            // Add event listeners for bulk action buttons
            bulkBurnButton.addEventListener('click', burnSelectedAssets);
            clearSelectionButton.addEventListener('click', clearSelection);


            // Achievement definitions
            const ACHIEVEMENTS = {
                FIRST_CONNECTION: {
                    id: 'first_connection',
                    title: 'Connected Explorer',
                    description: 'Connect your wallet for the first time',
                    icon: 'M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5',
                    maxProgress: 1
                },
                ASSET_VIEWER: {
                    id: 'asset_viewer',
                    title: 'Asset Explorer',
                    description: 'View your token collection',
                    icon: 'M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
                    maxProgress: 1
                },
                BURN_TOKENS: {
                    id: 'burn_tokens',
                    title: 'Token Burn Master',
                    description: 'Burn tokens 3 times',
                    icon: 'M13 10V3L4 14h7v7l9-11h-7z',
                    maxProgress: 3
                }
            };

            // Achievement tracking
            let userAchievements = {};

            function initializeAchievements() {
                const storedAchievements = localStorage.getItem('userAchievements');
                userAchievements = storedAchievements ? JSON.parse(storedAchievements) : {};

                // Initialize achievements if not exists
                Object.keys(ACHIEVEMENTS).forEach(key => {
                    if (!userAchievements[key]) {
                        userAchievements[key] = {
                            progress: 0,
                            completed: false
                        };
                    }
                });

                updateAchievementsDisplay();
                saveAchievements();
            }

            function updateAchievement(achievementId, progress = 1) {
                if (!userAchievements[achievementId]) return;

                const achievement = ACHIEVEMENTS[achievementId];
                userAchievements[achievementId].progress = Math.min(
                    userAchievements[achievementId].progress + progress,
                    achievement.maxProgress
                );

                if (userAchievements[achievementId].progress >= achievement.maxProgress) {
                    userAchievements[achievementId].completed = true;
                    showAchievementNotification(achievement.title);
                }

                updateAchievementsDisplay();
                saveAchievements();
            }

            function createAchievementCard(achievementId) {
                const achievement = ACHIEVEMENTS[achievementId];
                const userProgress = userAchievements[achievementId];
                const template = document.querySelector('#achievement-card-template');
                const card = template.content.cloneNode(true);

                card.querySelector('.achievement-title').textContent = achievement.title;
                card.querySelector('.achievement-description').textContent = achievement.description;
                card.querySelector('.achievement-svg').innerHTML = `<path d="${achievement.icon}" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;

                const progressPercent = (userProgress.progress /achievement.maxProgress) * 100;
                card.querySelector('.progress-fill').style.width = `${progressPercent}%`;
                card.querySelector('.progress-text').textContent =
                    `${userProgress.progress}/${achievement.maxProgress}`;

                const achievementCard = card.querySelector('.achievement-card');
                if (userProgress.completed) {
                    achievementCard.classList.add('completed');
                }

                return card;
            }

            function updateAchievementsDisplay() {
                const container = document.querySelector('.achievements-grid');
                if (!container) return;

                container.innerHTML = '';
                Object.keys(ACHIEVEMENTS).forEach(achievementId => {
                    const card = createAchievementCard(achievementId);
                    container.appendChild(card);
                });

                document.getElementById('achievementsContainer').style.display = 'block';
            }

            function showAchievementNotification(title) {
                const notification = document.createElement('div');
                notification.className = 'achievement-notification';
                notification.innerHTML = `
                    <div class="notification-content">
                        <span class="notification-icon">üèÜ</span>
                        <span>Achievement Unlocked: ${title}</span>
                    </div>
                `;

                document.body.appendChild(notification);
                setTimeout(() => {
                    notification.classList.add('show');
                    setTimeout(() => {
                        notification.classList.remove('show');
                        setTimeout(() => notification.remove(), 300);
                    }, 3000);
                }, 100);
            }

            function saveAchievements() {
                localStorage.setItem('userAchievements', JSON.stringify(userAchievements));
            }

            function setupBurnButton(burnButton, burnInput, token) {
                burnButton.addEventListener('click', async () => {
                    if (!validateBurnAmount(burnInput, token.amount)) {
                        return;
                    }

                    const amount = parseFloat(burnInput.value);
                    if (!confirm(`Are you sure you want to burn ${amount} ${token.symbol || 'tokens'}? This action cannot be undone.`)) {
                        return;
                    }

                    try {
                        showLoading(true);
                        const result = await burnToken(token.mint, amount, token.decimals);
                        if (result) {
                            showStatus('Token burned successfully');
                            burnInput.value = '';
                            // Update the display
                            token.amount -= amount;
                            const card = burnButton.closest('.asset-card');
                            card.querySelector('.balance-amount').textContent = formatNumber(token.amount);
                            if (token.amount <= 0) {
                                card.classList.add('burned');
                                setTimeout(() => {
                                    card.remove();
                                }, 500);
                            }
                        }
                    } catch (error) {
                        showError(`Failed to burn token: ${error.message}`);
                    } finally {
                        showLoading(false);
                    }
                });
            }

            function setupAssetSelection(card, asset, displayName) {
                const selector = card.querySelector('.asset-selector');
                const burnInput = card.querySelector('.burn-amount');

                selector.addEventListener('change', (e) => {
                    const isSelected = e.target.checked;
                    if (isSelected) {
                        selectedAssets.set(asset.mint, {
                            type: asset.is_nft ? 'nft' : 'token',
                            amount: parseFloat(burnInput.value) || asset.amount,
                            decimals: asset.decimals,
                            displayName: displayName
                        });
                        card.classList.add('selected');
                    } else {
                        selectedAssets.delete(asset.mint);
                        card.classList.remove('selected');
                    }
                    updateBulkActionsBar();
                });

                // Update amount when burn input changes
                if (burnInput) {
                    burnInput.addEventListener('change', () => {
                        if (selectedAssets.has(asset.mint)) {
                            selectedAssets.set(asset.mint, {
                                ...selectedAssets.get(asset.mint),
                                amount: parseFloat(burnInput.value) || asset.amount
                            });
                        }
                    });
                }
            }

            async function burnSelectedAssets() {
                if (selectedAssets.size === 0) {
                    showError('No assets selected for burning');
                    return;
                }

                // Create a summary of selected assets
                let summary = 'You are about to burn:\n';
                for (const [mint, asset] of selectedAssets) {
                    const amount = asset.type === 'nft' ? '1' : asset.amount;
                    summary += `\n- ${asset.displayName}: ${amount}`;
                }

                if (!confirm(`${summary}\n\nThis action cannot be undone. Do you want to continue?`)) {
                    return;
                }

                try {
                    showLoading(true);
                    const instructions = [];

                    // Create burn instructions for each selected asset
                    for (const [mint, asset] of selectedAssets) {
                        const burnInstructions = await burnToken(mint, asset.amount, asset.decimals);
                        instructions.push(...burnInstructions);
                    }

                    // Create and send transaction
                    const latestBlockhash = await connection.getLatestBlockhash();
                    const transaction = new solanaWeb3.Transaction({
                        feePayer: currentWallet.publicKey,
                        ...latestBlockhash,
                    });

                    transaction.add(...instructions);

                    const signed = await currentWallet.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(signed.serialize());
                    await connection.confirmTransaction(signature);

                    showStatus('Assets burned successfully');

                    // Remove burned assets from display
                    for (const [mint] of selectedAssets) {
                        const card = document.querySelector(`.asset-card[data-mint="${mint}"]`);
                        if (card) {
                            card.classList.add('burned');
                            setTimeout(() => {
                                card.remove();
                            }, 500);
                        }
                    }

                    // Clear selection
                    clearSelection();
                } catch (error) {
                    showError(`Failed to burn assets: ${error.message}`);
                } finally {
                    showLoading(false);
                }
            }

            // Initialize bulk burn functionality
            const bulkBurnButton = document.querySelector('.bulk-burn-button');
            if (bulkBurnButton) {
                bulkBurnButton.addEventListener('click', burnSelectedAssets);
            }

            const clearSelectionButton = document.querySelector('.clear-selection');
            if (clearSelectionButton) {
                clearSelectionButton.addEventListener('click', clearSelection);
            }

            initializeAchievements();
        });
    </script>
</body>
</html>