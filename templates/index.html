;
            padding: 1rem;
        }

        .collection-section {
            background: rgba(153, 69, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
        }

        .collection-header {
            color: #9945FF;
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #9945FF;
        }

        .collection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
        }
    </style>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Initializing wallet handler...");

            const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');

            const connectButton = document.getElementById('connectButton');
            const walletInfo = document.getElementById('walletInfo');
            const walletAddress = document.getElementById('walletAddress');
            const statusMessage = document.getElementById('statusMessage');
            const assetsContainer = document.getElementById('assetsContainer');
            const loadingMessage = document.getElementById('loadingMessage');
            const errorMessage = document.getElementById('errorMessage');

            let currentWallet = null;
            let connection = null;

            function showStatus(message, isError = false) {
                statusMessage.textContent = message;
                statusMessage.style.display = 'block';
                statusMessage.className = `status-message ${isError ? 'error' : 'success'}`;
                console.log(`Status: ${message}`);
            }

            function showLoading(show = true) {
                loadingMessage.style.display = show ? 'block' : 'none';
                if (show) {
                    errorMessage.style.display = 'none';
                }
            }

            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
                loadingMessage.style.display = 'none';
                console.error('Error:', message);
            }

            function getConnection() {
                const endpoint = '{{ rpc_endpoint }}';
                console.log('Using RPC endpoint:', endpoint);
                return new solanaWeb3.Connection(endpoint, {
                    commitment: 'confirmed',
                    wsEndpoint: false
                });
            }

            function setupIntelligentImageLoading(imgElement, primaryUrl, type = 'token') {
                imgElement.classList.add('loading');

                const defaultImages = {
                    'token': '{{ url_for('static', filename='default-token-icon.svg') }}',
                    'nft': '{{ url_for('static', filename='default-nft-image.svg') }}',
                    'cnft': '{{ url_for('static', filename='default-nft-image.svg') }}'
                };

                const ipfsGateways = [
                    'https://ipfs.io/ipfs/',
                    'https://gateway.pinata.cloud/ipfs/',
                    'https://cloudflare-ipfs.com/ipfs/',
                    'https://gateway.ipfs.io/ipfs/'
                ];

                async function tryLoadImage(url) {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(url);
                        img.onerror = () => reject();
                        img.src = url;
                    });
                }

                async function loadWithFallback() {
                    if (!primaryUrl) {
                        imgElement.src = defaultImages[type];
                        imgElement.classList.remove('loading');
                        return;
                    }

                    try {
                        await tryLoadImage(primaryUrl);
                        imgElement.src = primaryUrl;
                    } catch {
                        if (primaryUrl.startsWith('ipfs://')) {
                            const hash = primaryUrl.replace('ipfs://', '');
                            let loaded = false;

                            for (const gateway of ipfsGateways) {
                                try {
                                    const url = gateway + hash;
                                    await tryLoadImage(url);
                                    imgElement.src = url;
                                    loaded = true;
                                    break;
                                } catch {
                                    continue;
                                }
                            }

                            if (!loaded) {
                                imgElement.src = defaultImages[type];
                            }
                        } else {
                            imgElement.src = defaultImages[type];
                        }
                    }

                    imgElement.classList.remove('loading');
                }

                loadWithFallback();
            }

            function formatAddress(address) {
                return `${address.slice(0, 4)}...${address.slice(-4)}`;
            }

            function getDisplayName(asset, type = 'token') {
                if (type === 'token') {
                    // For tokens, try name + symbol if available
                    if (asset.name && asset.symbol) {
                        return `${asset.name} (${asset.symbol})`;
                    } else if (asset.name) {
                        return asset.name;
                    } else if (asset.symbol) {
                        return asset.symbol;
                    }
                } else if (type === 'nft') {
                    // For NFTs, try name + collection
                    if (asset.name && asset.collection) {
                        return `${asset.name} - ${asset.collection}`;
                    } else if (asset.name) {
                        return asset.name;
                    } else if (asset.collection) {
                        return `NFT from ${asset.collection}`;
                    }
                }
                // Fallback to formatted address
                return `${type === 'token' ? 'Token' : 'NFT'} ${formatAddress(asset.mint)}`;
            }

            function createTokenCard(token) {
                const template = document.querySelector('#token-card-template');
                const card = template.content.cloneNode(true);
                const cardElement = card.querySelector('.asset-card');
                cardElement.dataset.mint = token.mint;

                const iconElem = card.querySelector('.token-icon');
                setupIntelligentImageLoading(iconElem, token.icon, 'token');

                const displayName = getDisplayName(token, 'token');
                card.querySelector('.token-name').textContent = displayName;
                card.querySelector('.token-symbol').textContent = token.symbol || formatAddress(token.mint);
                card.querySelector('.balance-amount').textContent = formatNumber(token.amount);
                card.querySelector('.supply-amount').textContent = formatNumber(token.supply);
                card.querySelector('.price-amount').textContent = token.price_usd !== 'Unknown' ? `$${Number(token.price_usd).toFixed(6)}` : 'Unknown';
                card.querySelector('.volume-amount').textContent = token.volume_24h !== 'Unknown' ? `$${formatNumber(token.volume_24h)}` : 'Unknown';

                card.querySelector('.solscan-link').href = `https://solscan.io/token/${token.mint}`;

                const burnInput = card.querySelector('.burn-amount');
                burnInput.max = token.amount;
                burnInput.min = 0.000001;

                const burnButton = card.querySelector('.burn-button');
                burnButton.dataset.mint = token.mint;
                burnButton.dataset.decimals = token.decimals;

                setupBurnButton(burnButton, burnInput, token);

                const selector = card.querySelector('.asset-selector');
                selector.addEventListener('change', (e) => {
                    const isSelected = e.target.checked;
                    const card = e.target.closest('.asset-card');

                    if (isSelected) {
                        selectedAssets.set(token.mint, {
                            type: 'token',
                            amount: parseFloat(card.querySelector('.burn-amount').value) || token.amount,
                            decimals: token.decimals,
                            displayName: displayName
                        });
                        card.classList.add('selected');
                    } else {
                        selectedAssets.delete(token.mint);
                        card.classList.remove('selected');
                    }

                    updateBulkActionsBar();
                });

                burnInput.addEventListener('change', () => {
                    if (selectedAssets.has(token.mint)) {
                        selectedAssets.set(token.mint, {
                            ...selectedAssets.get(token.mint),
                            amount: parseFloat(burnInput.value) || token.amount
                        });
                    }
                });

                return card;
            }

            function createNFTCard(nft) {
                const template = document.querySelector('#nft-card-template');
                const card = template.content.cloneNode(true);
                const cardElement = card.querySelector('.asset-card');
                cardElement.dataset.mint = nft.mint;

                const imageElem = card.querySelector('.nft-image');
                setupIntelligentImageLoading(imageElem, nft.image, 'nft');

                const displayName = getDisplayName(nft, 'nft');
                card.querySelector('.nft-name').textContent = displayName;
                card.querySelector('.nft-collection').textContent = nft.collection || '';
                card.querySelector('.solscan-link').href = `https://solscan.io/token/${nft.mint}`;

                const burnButton = card.querySelector('.burn-button');
                burnButton.dataset.mint = nft.mint;

                burnButton.addEventListener('click', async () => {
                    if (!confirm(`Are you sure you want to burn this NFT (${displayName})? This action cannot be undone.`)) {
                        return;
                    }

                    try {
                        showLoading(true);
                        const result = await burnToken(nft.mint, 1, 0);
                        if (result) {
                            showStatus('NFT burned successfully');
                            card.classList.add('burned');
                            setTimeout(() => {
                                card.remove();
                            }, 500);
                        }
                    } catch (error) {
                        showError(`Failed to burn NFT: ${error.message}`);
                    } finally {
                        showLoading(false);
                    }
                });

                const selector = card.querySelector('.asset-selector');
                selector.addEventListener('change', (e) => {
                    const isSelected = e.target.checked;
                    const card = e.target.closest('.asset-card');

                    if (isSelected) {
                        selectedAssets.set(nft.mint, {
                            type: 'nft',
                            amount: 1,
                            decimals: 0,
                            displayName: displayName
                        });
                        card.classList.add('selected');
                    } else {
                        selectedAssets.delete(nft.mint);
                        card.classList.remove('selected');
                    }

                    updateBulkActionsBar();
                });

                return card;
            }

            function createCNFTCard(cnft) {
                const template = document.querySelector('#cnft-card-template');
                const card = template.content.cloneNode(true);

                const imageElem = card.querySelector('.cnft-image');
                setupIntelligentImageLoading(imageElem, cnft.image, 'cnft');

                card.querySelector('.cnft-name').textContent = cnft.name || 'Unnamed cNFT';
                card.querySelector('.cnft-collection').textContent = cnft.collection || '';

                return card;
            }

            function displayNFTs(nfts) {
                const nftsContainer = document.querySelector('#nfts .collections-grid');
                nftsContainer.innerHTML = '';

                if (!nfts || nfts.length === 0) {
                    nftsContainer.innerHTML = '<div class="no-assets">No NFTs found</div>';
                    return;
                }

                // Group NFTs by collection
                const nftsByCollection = nfts.reduce((acc, nft) => {
                    const collection = nft.collection || 'Other';
                    if (!acc[collection]) {
                        acc[collection] = [];
                    }
                    acc[collection].push(nft);
                    return acc;
                }, {});

                // Sort collections alphabetically
                const sortedCollections = Object.keys(nftsByCollection).sort((a, b) => {
                    if (a === 'Other') return 1;
                    if (b === 'Other') return -1;
                    return a.localeCompare(b);
                });

                // Create sections for each collection
                sortedCollections.forEach(collection => {
                    const collectionSection = document.createElement('div');
                    collectionSection.className = 'collection-section';

                    const header = document.createElement('div');
                    header.className = 'collection-header';
                    header.textContent = collection;
                    collectionSection.appendChild(header);

                    const grid = document.createElement('div');
                    grid.className = 'collection-grid';

                    // Sort NFTs within collection by name
                    const sortedNFTs = nftsByCollection[collection].sort((a, b) => {
                        return (a.name || '').localeCompare(b.name || '');
                    });

                    sortedNFTs.forEach(nft => {
                        const card = createNFTCard(nft);
                        grid.appendChild(card);
                    });

                    collectionSection.appendChild(grid);
                    nftsContainer.appendChild(collectionSection);
                });
            }

            async function loadAssets(publicKey) {
                showLoading(true);
                document.querySelectorAll('.assets-grid, .collections-grid').forEach(grid => {
                    grid.innerHTML = '';
                    grid.style.display = 'none';
                });

                try {
                    const response = await fetch(`/assets?wallet=${publicKey}`);
                    const data = await response.json();

                    if (!data.success) {
                        throw new Error(data.message || 'Failed to fetch assets');
                    }

                    const assets = data.assets;
                    const tokensGrid = document.querySelector('#tokens .assets-grid');

                    if (!assets.tokens || assets.tokens.length === 0) {
                        tokensGrid.innerHTML = '<div class="no-assets">No tokens found</div>';
                    } else {
                        assets.tokens.forEach(token => {
                            const card = createTokenCard(token);
                            tokensGrid.appendChild(card);
                        });
                    }

                    // Use the new displayNFTs function
                    displayNFTs(assets.nfts);

                    const cnftsGrid = document.querySelector('#cnfts .assets-grid');
                    if (!assets.cnfts || assets.cnfts.length === 0) {
                        cnftsGrid.innerHTML = '<div class="no-assets">No cNFTs found</div>';
                    } else {
                        assets.cnfts.forEach(cnft => {
                            const card = createCNFTCard(cnft);
                            cnftsGrid.appendChild(card);
                        });
                    }

                    showLoading(false);
                    document.querySelectorAll('.assets-grid, .collections-grid').forEach(grid => {
                        grid.style.display = 'grid';
                    });

                } catch (error) {
                    console.error('Error loading assets:', error);
                    showError(`Failed to load assets: ${error.message}`);
                }
            }

            async function connectWallet() {
                try {
                    if (!window.solana) {
                        showStatus('Phantom wallet not found. Please install Phantom.', true);
                        window.open('https://phantom.app/', '_blank');
                        return;
                    }

                    if (!window.solana.isPhantom) {
                        showStatus('Please install Phantom wallet', true);
                        return;
                    }

                    showStatus('Connecting to Phantom...');
                    const resp = await window.solana.connect();

                    if (resp.publicKey) {
                        const address = resp.publicKey.toString();
                        console.log('Connected to wallet:', address);
                        currentWallet = window.solana;
                        connection = getConnection();

                        connectButton.style.display = 'none';
                        walletInfo.style.display = 'block';
                        walletAddress.textContent = `Address: ${address.slice(0,6)}...${address.slice(-6)}`;
                        assetsContainer.style.display = 'block';

                        showStatus('Wallet connected successfully');
                        await loadAssets(address);

                        // Trigger first connection achievement
                        updateAchievement('FIRST_CONNECTION');

                        // Trigger asset viewer achievement when assets are loaded
                        updateAchievement('ASSET_VIEWER');
                    }
                } catch (error) {
                    console.error('Connection error:', error);
                    showStatus(`Failed to connect: ${error.message}`, true);
                }
            }

            connectButton.addEventListener('click', connectWallet);

            // Check if wallet is already connected
            if (window.solana && window.solana.isPhantom && window.solana.isConnected) {
                const publicKey = window.solana.publicKey.toString();
                currentWallet = window.solana;
                connection = getConnection();

                connectButton.style.display = 'none';
                walletInfo.style.display = 'block';
                walletAddress.textContent = `Address: ${publicKey.slice(0,6)}...${publicKey.slice(-6)}`;
                assetsContainer.style.display = 'block';

                showStatus('Wallet already connected');
                loadAssets(publicKey);
            }

            // Tab switching functionality
            const tabs = document.querySelectorAll('.tab-button');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));

                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                });
            });

            function formatNumber(num) {
                return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 6
                }).format(num);
            }

            function validateBurnAmount(input, maxAmount) {
                const amount = parseFloat(input.value);
                console.log('Validating burn amount:', amount, 'max:', maxAmount);

                if (isNaN(amount) || amount <= 0) {
                    showError('Please enter a valid amount greater than 0');
                    return false;
                }

                if (amount - maxAmount > Number.EPSILON) {
                    showError(`Amount cannot exceed ${maxAmount}`);
                    return false;
                }

                return true;
            }

            async function burnToken(mint, amount, decimals) {
                const mintPubkey = new solanaWeb3.PublicKey(mint);
                const walletPubkey = currentWallet.publicKey;

                console.log(`Creating burn instruction for ${mint}`);
                console.log(`- Amount: ${amount}`);
                console.log(`- Decimals: ${decimals}`);

                const effectiveDecimals = 6;
                const multiplier = BigInt(10 ** effectiveDecimals);
                const rawAmount = BigInt(Math.round(amount * Number(multiplier)));

                if (rawAmount <= BigInt(0)) {
                    throw new Error('Amount must be greater than 0');
                }

                const [tokenAccountPubkey] = await solanaWeb3.PublicKey.findProgramAddress(
                    [
                        walletPubkey.toBuffer(),
                        TOKEN_PROGRAM_ID.toBuffer(),
                        mintPubkey.toBuffer(),
                    ],
                    new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL')
                );

                // Create burn instruction
                const burnIx = createBurnInstruction(
                    tokenAccountPubkey,
                    mintPubkey,
                    walletPubkey,
                    rawAmount
                );

                // Create close account instruction to return rent
                const closeIx = new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: tokenAccountPubkey, isSigner: false, isWritable: true },
                        { pubkey: walletPubkey, isSigner: false, isWritable: true },
                        { pubkey: walletPubkey, isSigner: true, isWritable: false },
                    ],
                    programId: TOKEN_PROGRAM_ID,
                    data: new Uint8Array([9]) // Close account instruction using Uint8Array instead of Buffer
                });

                return [burnIx, closeIx];
            }

            function createBurnInstruction(tokenAccount, mint, owner, amount) {
                const dataLayout = new Uint8Array(9);
                dataLayout[0] = 8; // Burn instruction
                const amountBytes = new Uint8Array(8);
                const view = new DataView(amountBytes.buffer);
                view.setBigUint64(0, amount, true);
                dataLayout.set(amountBytes, 1);

                return new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: tokenAccount, isSigner: false, isWritable: true },
                        { pubkey: mint, isSigner: false, isWritable: true },
                        { pubkey: owner, isSigner: true, isWritable: false },
                    ],
                    programId: TOKEN_PROGRAM_ID,
                    data: dataLayout
                });
            }


            // Add bulk selection state
            let selectedAssets = new Map(); // Map of selected assets: mint -> {type, amount}
            const bulkActionsBar = document.querySelector('.bulk-actions-bar');
            const selectedCountDisplay = document.querySelector('.selected-count');
            const bulkBurnButton = document.querySelector('.bulk-burn-button');
            const clearSelectionButton = document.querySelector('.clear-selection');

            function updateBulkActionsBar() {
                const count = selectedAssets.size;
                if (count > 0) {
                    selectedCountDisplay.textContent = `${count} item${count === 1 ? '' : 's'} selected`;
                    bulkActionsBar.style.display = 'flex';
                } else {
                    bulkActionsBar.style.display = 'none';
                }
            }

            function clearSelection() {
                selectedAssets.clear();
                document.querySelectorAll('.asset-selector').forEach(checkbox => {
                    checkbox.checked = false;
                    checkbox.closest('.asset-card').classList.remove('selected');
                });
                updateBulkActionsBar();
            }

            async function burnSelectedAssets() {
                // Create a summary of selected assets
                let summary = 'You are about to burn:\n';
                for (const [mint, asset] of selectedAssets) {
                    const amount = asset.type === 'nft' ? '1' : asset.amount;
                    summary += `\n- ${asset.displayName}: ${amount}`;
                }

                if (!confirm(`${summary}\n\nThis action cannot be undone. Do you want to continue?`)) {
                    return;
                }

                showLoading(true);

                try {
                    const transaction = new solanaWeb3.Transaction();
                    let instructions = [];

                    // Collect all burn and close instructions
                    for (const [mint, asset] of selectedAssets) {
                        try {
                            const [burnIx, closeIx] = await burnToken(mint, asset.amount, asset.decimals);
                            instructions.push(burnIx, closeIx);
                        } catch (error) {
                            console.error(`Failed to create burn instruction for asset ${mint}:`, error);
                            showError(`Failed to create burn instruction: ${error.message}`);
                            return;
                        }
                    }

                    // Add all instructions to the transaction
                    transaction.add(...instructions);
                    transaction.feePayer = currentWallet.publicKey;

                    console.log('Getting latest blockhash...');
                    const { blockhash } = await connection.getLatestBlockhash('confirmed');
                    transaction.recentBlockhash = blockhash;

                    console.log('Sending batch transaction for signature...');
                    const signed = await currentWallet.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(signed.serialize());

                    console.log('Batch transaction sent:', signature);
                    showStatus(`Transaction sent: ${signature}`);

                    const confirmation = await connection.confirmTransaction(signature);
                    if (confirmation.value.err) {
                        throw new Error('Transaction failed to confirm');
                    }

                    showStatus(`Successfully burned ${selectedAssets.size} assets and returned rent`);

                    // Trigger burn achievement
                    updateAchievement('TOKEN_BURN_MASTER');

                    // Reload assets
                    await loadAssets(currentWallet.publicKey.toString());

                    clearSelection();
                } catch (error) {
                    console.error('Bulk burn error:', error);
                    showError(`Failed to process bulk burn: ${error.message}`);
                } finally {
                    showLoading(false);
                }
            }

            // Add event listeners for bulk action buttons
            bulkBurnButton.addEventListener('click', burnSelectedAssets);
            clearSelectionButton.addEventListener('click', clearSelection);


            // Achievement definitions
            const ACHIEVEMENTS = {
                FIRST_CONNECTION: {
                    id: 'first_connection',
                    title: 'Connected Explorer',
                    description: 'Connect your wallet for the first time',
                    icon: 'M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5',
                    maxProgress: 1
                },
                ASSET_VIEWER: {
                    id: 'asset_viewer',
                    title: 'Asset Explorer',
                    description: 'View your token collection',
                    icon: 'M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
                    maxProgress: 1
                },
                TOKEN_BURN_MASTER: {
                    id: 'token_burn_master',
                    title: 'Token Burn Master',
                    description: 'Burn tokens 3 times',
                    icon: 'M13 10V3L4 14h7v7l9-11h-7z',
                    maxProgress: 3
                }
            };

            // Achievement tracking
            let userAchievements = {};

            function initializeAchievements() {
                const storedAchievements = localStorage.getItem('userAchievements');
                userAchievements = storedAchievements ? JSON.parse(storedAchievements) : {};

                // Initialize achievements if not exists
                Object.keys(ACHIEVEMENTS).forEach(key => {
                    if (!userAchievements[key]) {
                        userAchievements[key] = {
                            progress: 0,
                            completed: false
                        };
                    }
                });

                updateAchievementsDisplay();
                saveAchievements();
            }

            function updateAchievement(achievementId, progress = 1) {
                if (!userAchievements[achievementId]) return;

                const achievement = ACHIEVEMENTS[achievementId];
                userAchievements[achievementId].progress = Math.min(
                    userAchievements[achievementId].progress + progress,
                    achievement.maxProgress
                );

                if (userAchievements[achievementId].progress >= achievement.maxProgress) {
                    userAchievements[achievementId].completed = true;
                    showAchievementNotification(achievement.title);
                }

                updateAchievementsDisplay();
                saveAchievements();
            }

            function createAchievementCard(achievementId) {
                const achievement = ACHIEVEMENTS[achievementId];
                const userProgress = userAchievements[achievementId];
                const template = document.querySelector('#achievement-card-template');
                const card = template.content.cloneNode(true);

                card.querySelector('.achievement-title').textContent = achievement.title;
                card.querySelector('.achievement-description').textContent = achievement.description;
                card.querySelector('.achievement-svg').innerHTML = `<path d="${achievement.icon}" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;

                const progressPercent = (userProgress.progress / achievement.maxProgress) * 100;
                card.querySelector('.progress-fill').style.width = `${progressPercent}%`;
                card.querySelector('.progress-text').textContent =
                    `${userProgress.progress}/${achievement.maxProgress}`;

                const achievementCard = card.querySelector('.achievement-card');
                if (userProgress.completed) {
                    achievementCard.classList.add('completed');
                }

                return card;
            }

            function updateAchievementsDisplay() {
                const container = document.querySelector('.achievements-grid');
                if (!container) return;

                container.innerHTML = '';
                Object.keys(ACHIEVEMENTS).forEach(achievementId => {
                    const card = createAchievementCard(achievementId);
                    container.appendChild(card);
                });

                document.getElementById('achievementsContainer').style.display = 'block';
            }

            function showAchievementNotification(title) {
                const notification = document.createElement('div');
                notification.className = 'achievement-notification';
                notification.innerHTML = `
                    <div class="notification-content">
                        <span class="notification-icon">🏆</span>
                        <span>Achievement Unlocked: ${title}</span>
                    </div>
                `;

                document.body.appendChild(notification);
                setTimeout(() => {
                    notification.classList.add('show');
                    setTimeout(() => {
                        notification.classList.remove('show');
                        setTimeout(() => notification.remove(), 300);
                    }, 3000);
                }, 100);
            }

            function saveAchievements() {
                localStorage.setItem('userAchievements', JSON.stringify(userAchievements));
            }

            function setupBurnButton(burnButton, burnInput, token) {
                burnButton.addEventListener('click', async () => {
                    const amount = parseFloat(burnInput.value);
                    if (!validateBurnAmount(burnInput, token.amount)) {
                        return;
                    }

                    if (!confirm(`Are you sure you want to burn ${amount} ${token.symbol || 'tokens'}? This action cannot be undone.`)) {
                        return;
                    }

                    const result = await burnToken(token.mint, amount, token.decimals);
                    if (result) {
                        burnInput.value = '';
                    }
                });
            }

            initializeAchievements();
        });
    </script>
</body>
</html>