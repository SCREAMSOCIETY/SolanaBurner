<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Solana Token Burner</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>Solana Token Burner</h1>
        <div class="wallet-section">
            <button id="connectButton" class="connect-button">
                <img src="{{ url_for('static', filename='phantom.svg') }}" alt="Phantom" class="wallet-icon">
                Connect Phantom
            </button>
            <div id="walletInfo" class="connected-status" style="display: none;">
                <div>Wallet Connected</div>
                <div id="walletAddress" class="wallet-address"></div>
            </div>
        </div>
        <div id="statusMessage" style="display: none;" class="status-message"></div>

        <template id="token-card-template">
            <div class="asset-card token-card">
                <div class="selection-overlay">
                    <input type="checkbox" class="asset-selector" aria-label="Select asset for burning">
                </div>
                <div class="token-header">
                    <div class="token-icon-wrapper">
                        <img class="token-icon" src="" alt="Token Icon" loading="lazy" />
                    </div>
                    <div class="token-info">
                        <h4 class="token-name"></h4>
                        <span class="token-symbol"></span>
                    </div>
                </div>
                <div class="token-details">
                    <div class="token-balance">
                        <span class="balance-label">Balance:</span>
                        <span class="balance-amount"></span>
                    </div>
                    <div class="token-supply">
                        <span class="supply-label">Supply:</span>
                        <span class="supply-amount"></span>
                    </div>
                    <div class="token-price">
                        <span class="price-label">Price USD:</span>
                        <span class="price-amount"></span>
                    </div>
                    <div class="token-volume">
                        <span class="volume-label">24h Volume:</span>
                        <span class="volume-amount"></span>
                    </div>
                </div>
                <div class="token-actions">
                    <input type="number" class="burn-amount" placeholder="Amount to burn" step="0.000001" />
                    <button class="burn-button">Burn Token</button>
                </div>
                <div class="links-container">
                    <a class="solscan-link" href="" target="_blank">View on Solscan</a>
                </div>
            </div>
        </template>

        <template id="nft-card-template">
            <div class="asset-card nft-card">
                <div class="selection-overlay">
                    <input type="checkbox" class="asset-selector" aria-label="Select NFT for burning">
                </div>
                <div class="nft-image-wrapper">
                    <img class="nft-image" src="" alt="NFT" loading="lazy" />
                </div>
                <div class="nft-info">
                    <h4 class="nft-name"></h4>
                    <p class="nft-collection"></p>
                </div>
                <div class="token-actions">
                    <button class="burn-button">Burn NFT</button>
                </div>
                <div class="links-container">
                    <a class="solscan-link" href="" target="_blank">View on Solscan</a>
                </div>
            </div>
        </template>

        <template id="cnft-card-template">
            <div class="asset-card cnft-card">
                <div class="cnft-image-wrapper">
                    <img class="cnft-image" src="" alt="cNFT" loading="lazy" />
                </div>
                <div class="cnft-info">
                    <h4 class="cnft-name"></h4>
                    <p class="cnft-collection"></p>
                </div>
            </div>
        </template>

        <div id="assetsContainer" class="assets-container" style="display: none;">
            <h2>Your Assets</h2>
            <div class="tabs">
                <button class="tab-button active" data-tab="tokens">Tokens</button>
                <button class="tab-button" data-tab="nfts">NFTs</button>
                <button class="tab-button" data-tab="cnfts">cNFTs</button>
            </div>
            <div id="loadingMessage" class="loading-message" style="display: none;">Loading assets...</div>
            <div id="errorMessage" class="error-message" style="display: none;"></div>

            <div class="bulk-actions-bar" style="display: none;">
                <div class="selected-count">0 items selected</div>
                <div class="bulk-actions">
                    <button class="bulk-burn-button">Burn Selected</button>
                    <button class="clear-selection">Clear Selection</button>
                </div>
            </div>

            <div class="tab-content">
                <div id="tokens" class="tab-panel active">
                    <div class="assets-grid"></div>
                </div>
                <div id="nfts" class="tab-panel">
                    <div class="assets-grid"></div>
                </div>
                <div id="cnfts" class="tab-panel">
                    <div class="assets-grid"></div>
                </div>
            </div>
        </div>
        
        <!-- Add achievements panel after the assets container -->
        <div id="achievementsContainer" class="achievements-container" style="display: none;">
            <h2>Achievements</h2>
            <div class="achievements-grid">
                <!-- Achievement cards will be dynamically added here -->
            </div>
        </div>

        <template id="achievement-card-template">
            <div class="achievement-card">
                <div class="achievement-icon">
                    <svg class="achievement-svg" viewBox="0 0 24 24" width="48" height="48">
                        <!-- Icon will be set dynamically -->
                    </svg>
                </div>
                <div class="achievement-info">
                    <h3 class="achievement-title"></h3>
                    <p class="achievement-description"></p>
                </div>
                <div class="achievement-progress">
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                    <span class="progress-text"></span>
                </div>
            </div>
        </template>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Initializing wallet handler...");

            const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');

            const connectButton = document.getElementById('connectButton');
            const walletInfo = document.getElementById('walletInfo');
            const walletAddress = document.getElementById('walletAddress');
            const statusMessage = document.getElementById('statusMessage');
            const assetsContainer = document.getElementById('assetsContainer');
            const loadingMessage = document.getElementById('loadingMessage');
            const errorMessage = document.getElementById('errorMessage');

            let currentWallet = null;
            let connection = null;

            function showStatus(message, isError = false) {
                statusMessage.textContent = message;
                statusMessage.style.display = 'block';
                statusMessage.className = `status-message ${isError ? 'error' : 'success'}`;
                console.log(`Status: ${message}`);
            }

            function showLoading(show = true) {
                loadingMessage.style.display = show ? 'block' : 'none';
                if (show) {
                    errorMessage.style.display = 'none';
                }
            }

            function showError(message) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
                loadingMessage.style.display = 'none';
                console.error('Error:', message);
            }

            function getConnection() {
                const endpoint = '{{ rpc_endpoint }}';
                console.log('Using RPC endpoint:', endpoint);
                return new solanaWeb3.Connection(endpoint, {
                    commitment: 'confirmed',
                    wsEndpoint: false
                });
            }

            function setupIntelligentImageLoading(imgElement, primaryUrl, type = 'token') {
                imgElement.classList.add('loading');

                const defaultImages = {
                    'token': '{{ url_for('static', filename='default-token-icon.svg') }}',
                    'nft': '{{ url_for('static', filename='default-nft-image.svg') }}',
                    'cnft': '{{ url_for('static', filename='default-nft-image.svg') }}'
                };

                const ipfsGateways = [
                    'https://ipfs.io/ipfs/',
                    'https://gateway.pinata.cloud/ipfs/',
                    'https://cloudflare-ipfs.com/ipfs/',
                    'https://gateway.ipfs.io/ipfs/'
                ];

                async function tryLoadImage(url) {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(url);
                        img.onerror = () => reject();
                        img.src = url;
                    });
                }

                async function loadWithFallback() {
                    if (!primaryUrl) {
                        imgElement.src = defaultImages[type];
                        imgElement.classList.remove('loading');
                        return;
                    }

                    try {
                        await tryLoadImage(primaryUrl);
                        imgElement.src = primaryUrl;
                    } catch {
                        if (primaryUrl.startsWith('ipfs://')) {
                            const hash = primaryUrl.replace('ipfs://', '');
                            let loaded = false;

                            for (const gateway of ipfsGateways) {
                                try {
                                    const url = gateway + hash;
                                    await tryLoadImage(url);
                                    imgElement.src = url;
                                    loaded = true;
                                    break;
                                } catch {
                                    continue;
                                }
                            }

                            if (!loaded) {
                                imgElement.src = defaultImages[type];
                            }
                        } else {
                            imgElement.src = defaultImages[type];
                        }
                    }

                    imgElement.classList.remove('loading');
                }

                loadWithFallback();
            }

            function createTokenCard(token) {
                const template = document.querySelector('#token-card-template');
                const card = template.content.cloneNode(true);

                const iconElem = card.querySelector('.token-icon');
                setupIntelligentImageLoading(iconElem, token.icon, 'token');

                card.querySelector('.token-name').textContent = token.name || `Token ${token.mint.slice(0,4)}...${token.mint.slice(-4)}`;
                card.querySelector('.token-symbol').textContent = token.symbol || 'Unknown';
                card.querySelector('.balance-amount').textContent = formatNumber(token.amount);
                card.querySelector('.supply-amount').textContent = formatNumber(token.supply);
                card.querySelector('.price-amount').textContent = token.price_usd !== 'Unknown' ? `$${Number(token.price_usd).toFixed(6)}` : 'Unknown';
                card.querySelector('.volume-amount').textContent = token.volume_24h !== 'Unknown' ? `$${formatNumber(token.volume_24h)}` : 'Unknown';

                card.querySelector('.solscan-link').href = `https://solscan.io/token/${token.mint}`;

                const burnInput = card.querySelector('.burn-amount');
                burnInput.max = token.amount;
                burnInput.min = 0.000001;

                const burnButton = card.querySelector('.burn-button');
                burnButton.dataset.mint = token.mint;
                burnButton.dataset.decimals = token.decimals;

                setupBurnButton(burnButton, burnInput, token);

                const selector = card.querySelector('.asset-selector');
                selector.addEventListener('change', (e) => {
                    const isSelected = e.target.checked;
                    const card = e.target.closest('.asset-card');

                    if (isSelected) {
                        selectedAssets.set(token.mint, {
                            type: 'token',
                            amount: parseFloat(card.querySelector('.burn-amount').value) || token.amount,
                            decimals: token.decimals
                        });
                        card.classList.add('selected');
                    } else {
                        selectedAssets.delete(token.mint);
                        card.classList.remove('selected');
                    }

                    updateBulkActionsBar();
                });

                // Update burn amount when changed
                burnInput.addEventListener('change', () => {
                    if (selectedAssets.has(token.mint)) {
                        selectedAssets.set(token.mint, {
                            ...selectedAssets.get(token.mint),
                            amount: parseFloat(burnInput.value) || token.amount
                        });
                    }
                });

                return card;
            }

            function createNFTCard(nft) {
                const template = document.querySelector('#nft-card-template');
                const card = template.content.cloneNode(true);

                const imageElem = card.querySelector('.nft-image');
                setupIntelligentImageLoading(imageElem, nft.image, 'nft');

                card.querySelector('.nft-name').textContent = nft.name || 'Unnamed NFT';
                card.querySelector('.nft-collection').textContent = nft.collection || '';
                card.querySelector('.solscan-link').href = `https://solscan.io/token/${nft.mint}`;

                const burnButton = card.querySelector('.burn-button');
                burnButton.dataset.mint = nft.mint;

                burnButton.addEventListener('click', async () => {
                    if (!confirm(`Are you sure you want to burn this NFT? This action cannot be undone.`)) {
                        return;
                    }

                    try {
                        showLoading(true);
                        const result = await burnToken(nft.mint, 1, 0); // NFTs always have amount 1 and decimals 0
                        if (result) {
                            showStatus('NFT burned successfully');
                            card.classList.add('burned');
                            setTimeout(() => {
                                card.remove();
                            }, 500);
                        }
                    } catch (error) {
                        showError(`Failed to burn NFT: ${error.message}`);
                    } finally {
                        showLoading(false);
                    }
                });

                const selector = card.querySelector('.asset-selector');
                selector.addEventListener('change', (e) => {
                    const isSelected = e.target.checked;
                    const card = e.target.closest('.asset-card');

                    if (isSelected) {
                        selectedAssets.set(nft.mint, {
                            type: 'nft',
                            amount: 1,
                            decimals: 0
                        });
                        card.classList.add('selected');
                    } else {
                        selectedAssets.delete(nft.mint);
                        card.classList.remove('selected');
                    }

                    updateBulkActionsBar();
                });

                return card;
            }

            function createCNFTCard(cnft) {
                const template = document.querySelector('#cnft-card-template');
                const card = template.content.cloneNode(true);

                const imageElem = card.querySelector('.cnft-image');
                setupIntelligentImageLoading(imageElem, cnft.image, 'cnft');

                card.querySelector('.cnft-name').textContent = cnft.name || 'Unnamed cNFT';
                card.querySelector('.cnft-collection').textContent = cnft.collection || '';

                return card;
            }

            async function loadAssets(publicKey) {
                showLoading(true);
                document.querySelectorAll('.assets-grid').forEach(grid => {
                    grid.innerHTML = '';
                    grid.style.display = 'none';
                });

                try {
                    const response = await fetch(`/assets?wallet=${publicKey}`);
                    const data = await response.json();

                    if (!data.success) {
                        throw new Error(data.message || 'Failed to fetch assets');
                    }

                    const assets = data.assets;
                    const assetTypes = {
                        tokens: document.querySelector('#tokens .assets-grid'),
                        nfts: document.querySelector('#nfts .assets-grid'),
                        cnfts: document.querySelector('#cnfts .assets-grid')
                    };

                    if (!assets.tokens || assets.tokens.length === 0) {
                        assetTypes.tokens.innerHTML = '<div class="no-assets">No tokens found</div>';
                    } else {
                        assets.tokens.forEach(token => {
                            const card = createTokenCard(token);
                            assetTypes.tokens.appendChild(card);
                        });
                    }

                    if (!assets.nfts || assets.nfts.length === 0) {
                        assetTypes.nfts.innerHTML = '<div class="no-assets">No NFTs found</div>';
                    } else {
                        assets.nfts.forEach(nft => {
                            const card = createNFTCard(nft);
                            assetTypes.nfts.appendChild(card);
                        });
                    }

                    if (!assets.cnfts || assets.cnfts.length === 0) {
                        assetTypes.cnfts.innerHTML = '<div class="no-assets">No cNFTs found</div>';
                    } else {
                        assets.cnfts.forEach(cnft => {
                            const card = createCNFTCard(cnft);
                            assetTypes.cnfts.appendChild(card);
                        });
                    }

                    showLoading(false);
                    document.querySelectorAll('.assets-grid').forEach(grid => {
                        grid.style.display = 'grid';
                    });

                } catch (error) {
                    console.error('Error loading assets:', error);
                    showError(`Failed to load assets: ${error.message}`);
                }
            }

            async function connectWallet() {
                try {
                    if (!window.solana) {
                        showStatus('Phantom wallet not found. Please install Phantom.', true);
                        window.open('https://phantom.app/', '_blank');
                        return;
                    }

                    if (!window.solana.isPhantom) {
                        showStatus('Please install Phantom wallet', true);
                        return;
                    }

                    showStatus('Connecting to Phantom...');
                    const resp = await window.solana.connect();

                    if (resp.publicKey) {
                        const address = resp.publicKey.toString();
                        console.log('Connected to wallet:', address);
                        currentWallet = window.solana;
                        connection = getConnection();

                        connectButton.style.display = 'none';
                        walletInfo.style.display = 'block';
                        walletAddress.textContent = `Address: ${address.slice(0,6)}...${address.slice(-6)}`;
                        assetsContainer.style.display = 'block';

                        showStatus('Wallet connected successfully');
                        await loadAssets(address);

                        // Trigger first connection achievement
                        updateAchievement('FIRST_CONNECTION');

                        // Trigger asset viewer achievement when assets are loaded
                        updateAchievement('ASSET_VIEWER');
                    }
                } catch (error) {
                    console.error('Connection error:', error);
                    showStatus(`Failed to connect: ${error.message}`, true);
                }
            }

            connectButton.addEventListener('click', connectWallet);

            // Check if wallet is already connected
            if (window.solana && window.solana.isPhantom && window.solana.isConnected) {
                const publicKey = window.solana.publicKey.toString();
                currentWallet = window.solana;
                connection = getConnection();

                connectButton.style.display = 'none';
                walletInfo.style.display = 'block';
                walletAddress.textContent = `Address: ${publicKey.slice(0,6)}...${publicKey.slice(-6)}`;
                assetsContainer.style.display = 'block';

                showStatus('Wallet already connected');
                loadAssets(publicKey);
            }

            // Tab switching functionality
            const tabs = document.querySelectorAll('.tab-button');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));

                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                });
            });

            function formatNumber(num) {
                return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 6
                }).format(num);
            }

            function validateBurnAmount(input, maxAmount) {
                const amount = parseFloat(input.value);
                console.log('Validating burn amount:', amount, 'max:', maxAmount);

                if (isNaN(amount) || amount <= 0) {
                    showError('Please enter a valid amount greater than 0');
                    return false;
                }

                if (amount - maxAmount > Number.EPSILON) {
                    showError(`Amount cannot exceed ${maxAmount}`);
                    return false;
                }

                return true;
            }
            async function burnToken(mint, amount, decimals) {
                showLoading();
                errorMessage.style.display = 'none';

                try {
                    console.log(`Attempting to burn ${amount} tokens from mint ${mint}`);
                    console.log(`Token decimals: ${decimals}`);

                    if (!connection) {
                        connection = getConnection();
                    }

                    const mintPubkey = new solanaWeb3.PublicKey(mint);
                    const walletPubkey = currentWallet.publicKey;

                    console.log(`Burn request details:`);
                    console.log(`- Input amount: ${amount}`);
                    console.log(`- Token decimals: ${decimals}`);

                    const effectiveDecimals = 6; 
                    const multiplier = BigInt(10 ** effectiveDecimals);
                    const rawAmount = BigInt(Math.round(amount * Number(multiplier)));

                    console.log(`- Using effective decimals: ${effectiveDecimals}`);
                    console.log(`- Multiplier: ${multiplier}`);
                    console.log(`- Raw amount to burn: ${rawAmount}`);
                    console.log(`- Final amount in tokens: ${Number(rawAmount) / Number(multiplier)}`);

                    if (rawAmount <= BigInt(0)) {
                        throw new Error('Amount must be greater than 0');
                    }

                    const [tokenAccountPubkey] = await solanaWeb3.PublicKey.findProgramAddress(
                        [
                            walletPubkey.toBuffer(),
                            TOKEN_PROGRAM_ID.toBuffer(),
                            mintPubkey.toBuffer(),
                        ],
                        new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL')
                    );

                    console.log('Creating burn instruction...');
                    const dataLayout = new Uint8Array(9);
                    dataLayout[0] = 8; 
                    const amountBytes = new Uint8Array(8);
                    const view = new DataView(amountBytes.buffer);
                    view.setBigUint64(0, rawAmount, true);
                    dataLayout.set(amountBytes, 1);

                    const burnIx = new solanaWeb3.TransactionInstruction({
                        keys: [
                            { pubkey: tokenAccountPubkey, isSigner: false, isWritable: true },
                            { pubkey: mintPubkey, isSigner: false, isWritable: true },
                            { pubkey: walletPubkey, isSigner: true, isWritable: false },
                        ],
                        programId: TOKEN_PROGRAM_ID,
                        data: dataLayout
                    });

                    const transaction = new solanaWeb3.Transaction().add(burnIx);
                    transaction.feePayer = walletPubkey;

                    console.log('Getting latest blockhash...');
                    const { blockhash } = await connection.getLatestBlockhash('confirmed');
                    transaction.recentBlockhash = blockhash;

                    console.log('Sending transaction for signature...');
                    const signed = await currentWallet.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(signed.serialize());

                    console.log('Transaction sent:', signature);
                    showStatus(`Transaction sent: ${signature}`);

                    const confirmation = await connection.confirmTransaction(signature);
                    if (confirmation.value.err) {
                        throw new Error('Transaction failed to confirm');
                    }

                    // Trigger burn achievement
                    updateAchievement('TOKEN_BURN_MASTER');

                    showStatus(`Successfully burned ${amount} tokens`);
                    await loadAssets(currentWallet.publicKey.toString());

                    return true;
                } catch (error) {
                    console.error('Burn error:', error);
                    showError(`Failed to burn token: ${error.message}`);
                    return false;
                } finally {
                    showLoading(false);
                }
            }


            // Achievement definitions
            const ACHIEVEMENTS = {
                FIRST_CONNECTION: {
                    id: 'first_connection',
                    title: 'Connected Explorer',
                    description: 'Connect your wallet for the first time',
                    icon: 'M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5',
                    maxProgress: 1
                },
                ASSET_VIEWER: {
                    id: 'asset_viewer',
                    title: 'Asset Explorer',
                    description: 'View your token collection',
                    icon: 'M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
                    maxProgress: 1
                },
                TOKEN_BURN_MASTER: {
                    id: 'token_burn_master',
                    title: 'Token Burn Master',
                    description: 'Burn tokens 3 times',
                    icon: 'M13 10V3L4 14h7v7l9-11h-7z',
                    maxProgress: 3
                }
            };

            // Achievement tracking
            let userAchievements = {};

            function initializeAchievements() {
                const storedAchievements = localStorage.getItem('userAchievements');
                userAchievements = storedAchievements ? JSON.parse(storedAchievements) : {};

                // Initialize achievements if not exists
                Object.keys(ACHIEVEMENTS).forEach(key => {
                    if (!userAchievements[key]) {
                        userAchievements[key] = {
                            progress: 0,
                            completed: false
                        };
                    }
                });

                updateAchievementsDisplay();
                saveAchievements();
            }

            function updateAchievement(achievementId, progress = 1) {
                if (!userAchievements[achievementId]) return;

                const achievement = ACHIEVEMENTS[achievementId];
                userAchievements[achievementId].progress = Math.min(
                    userAchievements[achievementId].progress + progress,
                    achievement.maxProgress
                );

                if (userAchievements[achievementId].progress >= achievement.maxProgress) {
                    userAchievements[achievementId].completed = true;
                    showAchievementNotification(achievement.title);
                }

                updateAchievementsDisplay();
                saveAchievements();
            }

            function createAchievementCard(achievementId) {
                const achievement = ACHIEVEMENTS[achievementId];
                const userProgress = userAchievements[achievementId];
                const template = document.querySelector('#achievement-card-template');
                const card = template.content.cloneNode(true);

                card.querySelector('.achievement-title').textContent = achievement.title;
                card.querySelector('.achievement-description').textContent = achievement.description;
                card.querySelector('.achievement-svg').innerHTML = `<path d="${achievement.icon}" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>`;

                const progressPercent = (userProgress.progress / achievement.maxProgress) * 100;
                card.querySelector('.progress-fill').style.width = `${progressPercent}%`;
                card.querySelector('.progress-text').textContent = 
                    `${userProgress.progress}/${achievement.maxProgress}`;

                const achievementCard = card.querySelector('.achievement-card');
                if (userProgress.completed) {
                    achievementCard.classList.add('completed');
                }

                return card;
            }

            function updateAchievementsDisplay() {
                const container = document.querySelector('.achievements-grid');
                if (!container) return;

                container.innerHTML = '';
                Object.keys(ACHIEVEMENTS).forEach(achievementId => {
                    const card = createAchievementCard(achievementId);
                    container.appendChild(card);
                });

                document.getElementById('achievementsContainer').style.display = 'block';
            }

            function showAchievementNotification(title) {
                const notification = document.createElement('div');
                notification.className = 'achievement-notification';
                notification.innerHTML = `
                    <div class="notification-content">
                        <span class="notification-icon">🏆</span>
                        <span>Achievement Unlocked: ${title}</span>
                    </div>
                `;

                document.body.appendChild(notification);
                setTimeout(() => {
                    notification.classList.add('show');
                    setTimeout(() => {
                        notification.classList.remove('show');
                        setTimeout(() => notification.remove(), 300);
                    }, 3000);
                }, 100);
            }

            function saveAchievements() {
                localStorage.setItem('userAchievements', JSON.stringify(userAchievements));
            }

            function setupBurnButton(burnButton, burnInput, token) {
                burnButton.addEventListener('click', async () => {
                    const amount = parseFloat(burnInput.value);
                    if (!validateBurnAmount(burnInput, token.amount)) {
                        return;
                    }

                    if (!confirm(`Are you sure you want to burn ${amount} ${token.symbol || 'tokens'}? This action cannot be undone.`)) {
                        return;
                    }

                    const result = await burnToken(token.mint, amount, token.decimals);
                    if (result) {
                        burnInput.value = '';
                    }
                });
            }

            // Add bulk selection state
            let selectedAssets = new Map(); // Map of selected assets: mint -> {type, amount}
            const bulkActionsBar = document.querySelector('.bulk-actions-bar');
            const selectedCountDisplay = document.querySelector('.selected-count');
            const bulkBurnButton = document.querySelector('.bulk-burn-button');
            const clearSelectionButton = document.querySelector('.clear-selection');

            function updateBulkActionsBar() {
                const count = selectedAssets.size;
                if (count > 0) {
                    selectedCountDisplay.textContent = `${count} item${count === 1 ? '' : 's'} selected`;
                    bulkActionsBar.style.display = 'flex';
                } else {
                    bulkActionsBar.style.display = 'none';
                }
            }

            function clearSelection() {
                selectedAssets.clear();
                document.querySelectorAll('.asset-selector').forEach(checkbox => {
                    checkbox.checked = false;
                    checkbox.closest('.asset-card').classList.remove('selected');
                });
                updateBulkActionsBar();
            }

            async function burnSelectedAssets() {
                if (!confirm(`Are you sure you want to burn ${selectedAssets.size} selected asset(s)? This action cannot be undone.`)) {
                    return;
                }

                showLoading(true);
                const burnResults = [];

                try {
                    for (const [mint, asset] of selectedAssets) {
                        try {
                            const result = await burnToken(mint, asset.amount, asset.decimals);
                            burnResults.push({ mint, success: result });
                        } catch (error) {
                            console.error(`Failed to burn asset ${mint}:`, error);
                            burnResults.push({ mint, success: false, error: error.message });
                        }
                    }

                    // Process results
                    const successful = burnResults.filter(r => r.success).length;
                    const failed = burnResults.filter(r => !r.success).length;

                    if (successful > 0) {
                        showStatus(`Successfully burned ${successful} asset${successful === 1 ? '' : 's'}${failed > 0 ? `, ${failed} failed` : ''}`);
                        // Trigger burn achievement
                        updateAchievement('TOKEN_BURN_MASTER');
                        // Reload assets
                        await loadAssets(currentWallet.publicKey.toString());
                    } else {
                        showError('Failed to burn selected assets');
                    }

                    clearSelection();
                } catch (error) {
                    console.error('Bulk burn error:', error);
                    showError(`Failed to process bulk burn: ${error.message}`);
                } finally {
                    showLoading(false);
                }
            }

            // Add event listeners for bulk action buttons
            bulkBurnButton.addEventListener('click', burnSelectedAssets);
            clearSelectionButton.addEventListener('click', clearSelection);

            initializeAchievements();
        });
    </script>
</body>
</html>